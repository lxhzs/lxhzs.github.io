<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="description"><meta name="keyword"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>JS 进阶知识-高级篇</title><link rel="shortcut icon" href="/images/avatar.jpg" type="image/x-icon"><link href="/styles/site.css" rel="stylesheet"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><body></body><header class="container" id="header"><div class="header"><div class="header-left"><div class="avatar"><img src="/images/avatar.jpg"></div><div class="author"><div class="author-name"><a href="/">Levi丶Blog</a></div><div class="about-me">大家好，我叫李新华。我的域名是“李新华真帅”。</div></div></div><div class="header-right"><ul class="navigation"><li><a href="/"><i class="fa fa-fw fa-home"> </i><br>首页</a></li><li><a href="/"><i class="fa fa-fw fa-book"> </i><br>博客</a></li><li><a href="/archives"><i class="fa fa-fw fa-archive"> </i><br>归档</a></li><li><a href="/categories"><i class="fa fa-fw fa-th"> </i><br>分类</a></li><li><a href="/tags"><i class="fa fa-fw fa-tags"> </i><br>标签</a></li><li><a href="/life"><i class="fa fa-fw fa-heart"> </i><br>生活</a></li><li><a href="/about"><i class="fa fa-fw fa-user"> </i><br>关于</a></li></ul></div><div class="about-me-mask"><div class="about-me-wrap"><div class="about-me__header"><div class="avatar"><img src="/images/avatar.jpg"></div></div><ul class="socials"><li class="social-item"><span class="label"><img src="/images/socials/github.svg" alt="https://github.com/gary-Shen"></span><a href="https://github.com/gary-Shen" target="_blank" title="https://github.com/gary-Shen">https://github.com/gary-Shen</a></li><li class="social-item"><span class="label"><img src="/images/socials/email.svg" alt="guanlinshen@126.com"></span><span>guanlinshen@126.com</span></li><li class="social-item"><span class="label"><img src="/images/socials/wechat.svg" alt="Grinson"></span><span>Grinson</span></li></ul></div></div></div></header><div class="container post"><section class="article"><div class="title">JS 进阶知识-高级篇</div><div class="date">写于2018年12月27日</div><div class="content"><p><img src="http://ww1.sinaimg.cn/large/007kscFEgy1fyl4yha8ylj31400p0ac4.jpg" alt="image"></p>
<a id="more"></a>
<h1 id="js高级"><a class="header-anchor" href="#js高级"></a>JS高级</h1>
<h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2>
<blockquote>
<p>经过前面几篇文章的学习，相信大家已经对<code>js</code>有了部分的理解了，但是要想真正的掌握好<code>js</code>，本篇才是关键。由于<code>js</code>高级阶段的知识点比较难理解，所以本篇文章花了大量的时间去理思路，有可能有一些知识点遗漏了，也有肯能有部分知识点写的不对，欢迎大家留言纠正。另外，大家在以后的学习中千万不要被一些难点所吓到，听说有些知识点很难，其实并不是真正的难，只要你静下心慢慢的理解，其实还是很简单的。</p>
</blockquote>
<h2 id="1-异常处理"><a class="header-anchor" href="#1-异常处理"></a>1.异常处理</h2>
<p><strong>常见的异常分类</strong></p>
<ul>
<li>运行环境的多样性导致的异常（浏览器）</li>
<li>语法错误，代码错误</li>
</ul>
<p><em>异常最大的特征，就是一旦代码出现异常，后面的代码就不会执行。</em></p>
<h3 id="1-1异常捕获"><a class="header-anchor" href="#1-1异常捕获"></a>1.1异常捕获</h3>
<blockquote>
<p>捕获异常，使用<code>try-catch</code>语句：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// 这里写可能出现异常的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">    <span class="comment">// e-捕获的异常对象</span></span><br><span class="line">    <span class="comment">// 可以在此处书写出现异常后的处理代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>异常捕获语句执行的过程为：</p>
</blockquote>
<ul>
<li>
<p>代码正常运行, 如果在<code>try</code>中出现了错误,<code>try</code>里面出现错误的语句后面的代码都不再执行, 直接跳转到<code>catch</code>中</p>
</li>
<li>
<p><code>catch</code>中处理错误信息</p>
</li>
<li>
<p>然后继续执行后面的代码</p>
</li>
<li>
<p>如果<code>try</code>中没有出现错误, 那么不走<code>catch</code>直接执行后面的代码</p>
</li>
</ul>
<p><em>通过<code>try-catch</code>语句进行异常捕获之后，代码将会继续执行，而不会中断。</em></p>
<p><strong>示例代码：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'代码开始执行'</span>);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num); <span class="comment">// num 在外部是没有定义的</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我已经把错误处理了'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'代码结束执行'</span>);</span><br></pre></td></tr></table></figure>
<p><strong>效果图：</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/9c47d583gy1fs3j10vw5xj20a004it8m.jpg" alt="image"></p>
<p><em>从效果图中我们可以看到，<code>num</code>是一个没有定义的变量，如果没有放在<code>try-catch</code>代码块中，后面的‘代码结束执行’就不会被打印。通过把<code>try-catch</code>放在代码块中，出现错误后，就不会影响后面代码的运行了，他会把错误信息打印出来。</em></p>
<p><strong>注意：</strong></p>
<ul>
<li>
<p>语法错误异常用<code>try-catch</code>语句无法捕获，因为在预解析阶段，语法错误会直接检测出来，而不会等到运行的时候才报错。</p>
</li>
<li>
<p><code>try-catch</code>在一般日常开发中基本用不到，但是如果要写框架什么的，用的会非常多。因为这个会让框架变得健壮</p>
</li>
</ul>
<p><strong>异常捕获语句的完整模式</strong></p>
<blockquote>
<p>异常捕获语句的完整模式为<code>try-catch-finally</code></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//可能出现错误的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> ( e ) &#123;</span><br><span class="line">    <span class="comment">//如果出现错误就执行</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//结束 try 这个代码块之前执行, 即最后执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em><code>finally</code>中的代码，不管有没有发生异常，都会执行。一般用在后端语言中，用来释放资源，<code>JavaScript</code>中很少会用到</em></p>
<h3 id="1-2抛出异常"><a class="header-anchor" href="#1-2抛出异常"></a>1.2抛出异常</h3>
<p>如何手动的抛出异常呢？</p>
<blockquote>
<p>案例：自己写的一个函数，需要一个参数，如果用户不传参数，此时想直接给用户抛出异常，就需要了解如何抛出异常。</p>
</blockquote>
<p>抛出异常使用<code>throw</code>关键字，语法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> 异常对象;</span><br></pre></td></tr></table></figure>
<p>异常对象一般是用<code>new Error(&quot;异常消息&quot;)</code>, 也可以使用任意对象</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">para</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(para == <span class="literal">undefined</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"请传递参数"</span>);</span><br><span class="line">        <span class="comment">//这里也可以使用自定义的对象</span></span><br><span class="line">        <span class="keyword">throw</span> &#123;<span class="string">"id"</span>:<span class="number">1</span>, <span class="attr">msg</span>:<span class="string">"参数未传递"</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    test();</span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>效果图：</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/9c47d583gy1fs3jgx3t6lj209r01j0sj.jpg" alt="image"></p>
<p><img src="http://ww1.sinaimg.cn/large/9c47d583gy1fs3jegw83fj206k00m0si.jpg" alt="image"></p>
<h3 id="1-3异常的传递机制"><a class="header-anchor" href="#1-3异常的传递机制"></a>1.3异常的传递机制</h3>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    f2(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    f3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>( <span class="string">'error'</span> );</span><br><span class="line">&#125;</span><br><span class="line">f1();  <span class="comment">// f1 称为调用者, 或主调函数, f2 称为被调用者, 或被调函数</span></span><br></pre></td></tr></table></figure>
<p><em>当在被调函数内发生异常的时候，异常会一级一级往上抛出。</em></p>
<h2 id="2-面向对象编程"><a class="header-anchor" href="#2-面向对象编程"></a>2.面向对象编程</h2>
<blockquote>
<p>在了解面向对象编程之前，我们先来了解下什么是面向过程，什么是面向对象，他们之间的区别是什么。</p>
</blockquote>
<h3 id="2-1-面向过程和面向对象的的对比"><a class="header-anchor" href="#2-1-面向过程和面向对象的的对比"></a>2.1 面向过程和面向对象的的对比</h3>
<p><strong>举个例子：</strong></p>
<blockquote>
<p>日常洗衣服</p>
</blockquote>
<p><strong>1.面向过程的思维方式：</strong></p>
<blockquote>
<p>面向过程编程：将解决问题的关注点放在解决问题的具体细节上，关注如何一步一步实现代码细节；</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">step 1:收拾脏衣服</span><br><span class="line">step 2:打开洗衣机盖</span><br><span class="line">step 3:将脏衣服放进去</span><br><span class="line">step 4:设定洗衣程序</span><br><span class="line">step 5:开始洗衣服</span><br><span class="line">step 6:打开洗衣机盖子</span><br><span class="line">step 7:晒衣服</span><br></pre></td></tr></table></figure>
<p><strong>2.面向对象的思维方式：</strong></p>
<blockquote>
<p>面向对象编程：将解决问题的关注点放在解决问题所需的对象上，我们重点找对象；</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">人（对象）</span><br><span class="line">洗衣机（对象）</span><br></pre></td></tr></table></figure>
<p><em>在面向对象的思维方式中：我们只关心要完成事情需要的对象，面向对象其实就是对面向过程的封装；</em></p>
<p><strong>示例代码：</strong></p>
<blockquote>
<p>在页面上动态创建一个元素</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//面向过程</span></span><br><span class="line"><span class="comment">//1-创建一个div</span></span><br><span class="line"><span class="keyword">var</span>  div=<span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line"><span class="comment">//2-div设置内容</span></span><br><span class="line">div.innerHTML=<span class="string">'我是div'</span>;</span><br><span class="line"><span class="comment">//3-添加到页面中</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line"></span><br><span class="line"><span class="comment">//面向对象</span></span><br><span class="line">$(<span class="string">'body'</span>).append(<span class="string">'&lt;div&gt;我也是div&lt;/div&gt;'</span>);</span><br></pre></td></tr></table></figure>
<p><em>我们可以看出，<code>jQ</code>封装的其实就是对面向过程的封装。</em></p>
<p><strong>总结：</strong> 面向对象是一种解决问题的思路，一种编程思想。</p>
<h3 id="2-2-面向对象编程举例"><a class="header-anchor" href="#2-2-面向对象编程举例"></a>2.2 面向对象编程举例</h3>
<blockquote>
<p>设置页面中的<code>div</code>和<code>p</code>的边框为<code>'1px solid red'</code></p>
</blockquote>
<p><strong>1、传统的处理办法</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1&gt; 获取div标签</span></span><br><span class="line"><span class="keyword">var</span> divs = <span class="built_in">document</span>.getElementsByTagName( <span class="string">'div'</span> );</span><br><span class="line"><span class="comment">// 2&gt; 遍历获取到的div标签</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; divs.length; i++) &#123;</span><br><span class="line">    <span class="comment">//3&gt; 获取到每一个div元素,设置div的样式</span></span><br><span class="line">    divs[i].style.border = <span class="string">"1px dotted black"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4&gt; 获取p标签</span></span><br><span class="line"><span class="keyword">var</span> ps = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"p"</span>);</span><br><span class="line"><span class="comment">// 5&gt; 遍历获取到的p标签</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; ps.length; j++) &#123; </span><br><span class="line">    <span class="comment">// 获取到每一个p元素 设置p标签的样式</span></span><br><span class="line">    ps[j].style.border = <span class="string">"1px dotted black"</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2、使用函数进行封装优化</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过标签名字来获取页面中的元素 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">tagName</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">document</span>.getElementsByTagName(tagName); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装一个设置样式的函数 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setStyle</span>(<span class="params">arr</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123; </span><br><span class="line">        <span class="comment">// 获取到每一个div或者p元素 </span></span><br><span class="line">        arr[i].style.border = <span class="string">"1px solid #abc"</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> dvs = tag(<span class="string">"div"</span>);</span><br><span class="line"><span class="keyword">var</span> ps = tag(<span class="string">"p"</span>);</span><br><span class="line">setStyle(dvs); </span><br><span class="line">setStyle(ps);</span><br></pre></td></tr></table></figure>
<p><strong>3、使用面向对象的方式</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更好的做法：是将功能相近的代码放到一起 </span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;     <span class="comment">// 命名空间</span></span><br><span class="line">    getEle: &#123; </span><br><span class="line">        tag: <span class="function"><span class="keyword">function</span> (<span class="params">tagName</span>) </span>&#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">document</span>.getElementsByTagName(tagName); </span><br><span class="line">        &#125;, </span><br><span class="line">        id: <span class="function"><span class="keyword">function</span> (<span class="params">idName</span>) </span>&#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">document</span>.getElementById(idName); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;,    </span><br><span class="line">    setCss: &#123; </span><br><span class="line">        setStyle: <span class="function"><span class="keyword">function</span> (<span class="params">arr</span>) </span>&#123; </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123; </span><br><span class="line">                arr[i].style.border = <span class="string">"1px solid #abc"</span>; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;, </span><br><span class="line">        css: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;, </span><br><span class="line">        addClass: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;, </span><br><span class="line">        removeClass: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125; </span><br><span class="line">        <span class="comment">// ... </span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 属性操作模块 </span></span><br><span class="line">    <span class="comment">// 动画模块 </span></span><br><span class="line">    <span class="comment">// 事件模块 </span></span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> divs = obj.getEle.tag(<span class="string">'div'</span>);</span><br><span class="line">obj.setCss.setStyle(divs);</span><br></pre></td></tr></table></figure>
<h3 id="2-3-面向对象的三大特性"><a class="header-anchor" href="#2-3-面向对象的三大特性"></a>2.3 面向对象的三大特性</h3>
<blockquote>
<p>面向对象的三大特性分别是：<code>'封装'</code>，<code>'继承'</code>，<code>'多态'</code>。</p>
</blockquote>
<p><strong>1、封装性</strong></p>
<blockquote>
<p>对象就是对属性和方法的封装，要实现一个功能，对外暴露一些接口，调用者只需通过接口调用即可，不需要关注接口内部实现原理。</p>
</blockquote>
<ul>
<li>
<p><code>js</code>对象就是“键值对”的集合</p>
<ul>
<li>键值如果是数据( 基本数据, 复合数据, 空数据 ), 就称为属性</li>
<li>如果键值是函数, 那么就称为方法</li>
</ul>
</li>
<li>
<p>对象就是将属性与方法封装起来</p>
</li>
<li>
<p>方法是将过程封装起来</p>
</li>
</ul>
<p><strong>2、继承性</strong></p>
<blockquote>
<p>所谓继承就是自己没有, 别人有,拿过来为自己所用, 并成为自己的东西</p>
</blockquote>
<p><strong><em>2.1、传统继承基于模板</em></strong></p>
<p>子类可以使用从父类继承的属性和方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"> string name;</span><br><span class="line"> int age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student : Person &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> stu = <span class="keyword">new</span> Student();</span><br><span class="line">stu.name</span><br></pre></td></tr></table></figure>
<p><em>即：让某个类型的对象获得另一个类型的对象的属性的方法</em></p>
<p><strong><em>2.2、js 继承基于对象</em></strong></p>
<p>在<code>JavaScript</code>中，继承就是当前对象可以使用其他对象的方法和属性。</p>
<p><code>js</code>继承实现举例：混入（<code>mix</code>）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数o1和o2是两个对象，其中o1对象继承了所有o2对象的“k”属性或者方法</span></span><br><span class="line"><span class="keyword">var</span> o1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = &#123;</span><br><span class="line">    name: <span class="string">'Levi'</span>,</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    gender: <span class="string">'male'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mix</span> (<span class="params"> o1, o2 </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">var</span> k <span class="keyword">in</span> o2 ) &#123;</span><br><span class="line">        o1[ k ] = o2[ k ];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">mix(o1, o2);</span><br><span class="line"><span class="built_in">console</span>.log(o1.name); <span class="comment">// "Levi"</span></span><br></pre></td></tr></table></figure>
<p><strong>3、多态性（基于强类型，js中没有多态）只做了解</strong></p>
<blockquote>
<p>同一个类型的变量可以表现出不同形态，用父类的变量指向子类的对象。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">动物 animal = <span class="keyword">new</span> 子类(); <span class="comment">// 子类：麻雀、狗、猫、猪、狐狸...</span></span><br><span class="line">动物 animal = <span class="keyword">new</span> 狗();</span><br><span class="line">animal.叫();</span><br></pre></td></tr></table></figure>
<h3 id="2-4-创建对象的方式"><a class="header-anchor" href="#2-4-创建对象的方式"></a>2.4 创建对象的方式</h3>
<p><strong>1、字面量 {}</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> student1 = &#123;</span><br><span class="line">    name:<span class="string">'诸葛亮'</span>,</span><br><span class="line">    score:<span class="number">100</span>,</span><br><span class="line">    code:<span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> student2 = &#123;</span><br><span class="line">    name:<span class="string">'蔡文姬'</span>,</span><br><span class="line">    score:<span class="number">98</span>,</span><br><span class="line">    code:<span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> student3 = &#123;</span><br><span class="line">    name:<span class="string">'张飞'</span>,</span><br><span class="line">    score:<span class="number">68</span>,</span><br><span class="line">    code:<span class="number">3</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>字面量创建方式，代码复用性太低，每一次都需要重新创建一个对象。</em></p>
<p><strong>2、Object()构造函数</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> student1 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    student1.name = <span class="string">'诸葛亮'</span>;</span><br><span class="line">    student1.score = <span class="number">100</span>;</span><br><span class="line">    student1.code = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> student2 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    student2.name = <span class="string">'蔡文姬'</span>;</span><br><span class="line">    student2.score = <span class="number">98</span>;</span><br><span class="line">    student2.code = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> student3 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    student3.name = <span class="string">'张飞'</span>;</span><br><span class="line">    student3.score = <span class="number">68</span>;</span><br><span class="line">    student3.code = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p><em>代码复用性太低，字面量创建的方式其实就是代替<code>Object()</code>构造函数创建方式的。</em></p>
<p><strong>3、自定义构造函数</strong></p>
<blockquote>
<p>自定义构造函数，可以快速创建多个对象，并且代码复用性高。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般为了区分构造函数与普通函数，构造函数名首字母大写</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name,score,code</span>)</span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.score = score;</span><br><span class="line">    <span class="keyword">this</span>.code = code;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stu1 = <span class="keyword">new</span> Student(<span class="string">'诸葛亮'</span>,<span class="number">100</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> stu2 = <span class="keyword">new</span> Student(<span class="string">'蔡文姬'</span>,<span class="number">98</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> stu3 = <span class="keyword">new</span> Student(<span class="string">'张飞'</span>,<span class="number">68</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p><strong>构造函数语法：</strong></p>
<ul>
<li>构造函数名首字母大写；</li>
<li>构造函数一般与关键字：<code>new</code>一起使用；</li>
<li>构造函数一般不需要设置<code>return</code>语句，默认返回的是新创建的对象；</li>
<li><code>this</code>指向的是新创建的对象。</li>
</ul>
<p><strong>构造函数的执行过程：</strong></p>
<ul>
<li><code>new</code>关键字，创建一个新的对象，会在内存中开辟一个新的储存空间；</li>
<li>让构造函数中的<code>this</code>指向新创建的对象；</li>
<li>执行构造函数，给新创建的对象进行初始化（赋值）；</li>
<li>构造函数执行（初始化）完成，会将新创建的对象返回。</li>
</ul>
<p><strong>构造函数的注意点：</strong></p>
<ul>
<li>构造函数本身也是函数；</li>
<li>构造函数有返回值，默认返回的是新创建的对象；</li>
<li>但是如果手动添加返回值，添加的是值类型数据的时候，构造函数没有影响。如果添加的是引用类型（数组、对象等）值的时候，会替换掉新创建的对象。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=<span class="string">"哈士奇"</span>;</span><br><span class="line">    <span class="keyword">this</span>.age=<span class="number">0.5</span>;</span><br><span class="line">    <span class="keyword">this</span>.watch=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'汪汪汪，禁止入内'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// return false;          返回值不会改变，还是新创建的对象</span></span><br><span class="line">    <span class="comment">// return 123;            返回值不会改变，还是新创建的对象</span></span><br><span class="line">    <span class="comment">// return [1,2,3,4,5];    返回值发生改变，返回的是这个数组</span></span><br><span class="line">    <span class="keyword">return</span>  &#123;<span class="attr">aaa</span>:<span class="string">'bbbb'</span>&#125;;  <span class="comment">// 返回值发生改变，返回的是这个对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d1=<span class="keyword">new</span> Dog();  <span class="comment">// 新创建一个对象</span></span><br><span class="line"><span class="built_in">console</span>.log(d1);</span><br></pre></td></tr></table></figure>
<ul>
<li>构造函数可以当做普通函数执行，里面的<code>this</code>指向的是全局对象<code>window</code>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=<span class="string">"husky"</span>;</span><br><span class="line">    <span class="keyword">this</span>.age=<span class="number">0.5</span>;</span><br><span class="line">    <span class="keyword">this</span>.watch=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'汪汪汪，禁止入内'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);  <span class="comment">// window对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Dog());  <span class="comment">// 打印 1</span></span><br></pre></td></tr></table></figure>
<h3 id="2-5-面向对象案例"><a class="header-anchor" href="#2-5-面向对象案例"></a>2.5 面向对象案例</h3>
<blockquote>
<p>通过一个案例，我们来了解下面向对象编程（案例中有一个<code>prototype</code>概念，可以学完原型那一章后再来看这个案例）。</p>
</blockquote>
<p><strong>需求：</strong></p>
<ul>
<li>实现一个<code>MP3</code>音乐管理案例；</li>
<li>同种类型的<code>MP3</code>，厂家会生产出成百上千个，但是每个<code>MP3</code>都有各自的样式、使用者、歌曲；</li>
<li>每个<code>MP3</code>都有一样的播放、暂停、增删歌曲的功能（方法）；</li>
</ul>
<p><strong>图解：</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/9c47d583gy1ftpzainrzcj20lp0bcaao.jpg" alt="image"></p>
<p><strong>示例代码：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个MP3都有自己的 主人：owner 样式：color 歌曲：list</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MP3</span>(<span class="params">name,color,list</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.owner = name || <span class="string">'Levi'</span>;  <span class="comment">// 不传值时默认使用者是‘Levi’</span></span><br><span class="line">    <span class="keyword">this</span>.color = color || <span class="string">'pink'</span>;</span><br><span class="line">    <span class="keyword">this</span>.musicList = list || [</span><br><span class="line">        &#123;<span class="attr">songName</span>:<span class="string">'男人哭吧不是罪'</span>,<span class="attr">singer</span>:<span class="string">'刘德华'</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">songName</span>:<span class="string">'吻别'</span>,<span class="attr">singer</span>:<span class="string">'张学友'</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">songName</span>:<span class="string">'对你爱不完'</span>,<span class="attr">singer</span>:<span class="string">'郭富城'</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">songName</span>:<span class="string">'今夜你会不会来'</span>,<span class="attr">singer</span>:<span class="string">'黎明'</span>&#125;</span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 所有的MP3都有 播放 暂停 音乐 增删改查的功能</span></span><br><span class="line">MP3.prototype = &#123;</span><br><span class="line">    <span class="comment">// 新增</span></span><br><span class="line">    add:<span class="function"><span class="keyword">function</span>(<span class="params">songName,singer</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.musicList.push(&#123;<span class="attr">songName</span>:songName,<span class="attr">singer</span>:singer&#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 查找</span></span><br><span class="line">    select:<span class="function"><span class="keyword">function</span>(<span class="params">songName</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>.musicList.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.musicList[i].songName == songName)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.musicList[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  <span class="comment">// 如果没有搜索到返回null</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 修改</span></span><br><span class="line">    update:<span class="function"><span class="keyword">function</span>(<span class="params">songName,singer</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 先找到这首歌 在修改</span></span><br><span class="line">        <span class="keyword">var</span> result = <span class="keyword">this</span>.select(songName); <span class="comment">// 查找</span></span><br><span class="line">        <span class="keyword">if</span>(result)&#123;</span><br><span class="line">            result.singer = singer; <span class="comment">// 修改</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    <span class="keyword">delete</span>:<span class="function"><span class="keyword">function</span>(<span class="params">songName</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 先找到音乐  splice(index,1)</span></span><br><span class="line">        <span class="keyword">var</span> result = <span class="keyword">this</span>.select(songName);</span><br><span class="line">        <span class="comment">// 知道该音乐的索引值</span></span><br><span class="line">        <span class="comment">// 删除</span></span><br><span class="line">        <span class="keyword">if</span>(result)&#123;</span><br><span class="line">           <span class="keyword">var</span> index = <span class="keyword">this</span>.musicList.indexOf(result);</span><br><span class="line">           <span class="keyword">this</span>.musicList.splice(index,<span class="number">1</span>); <span class="comment">// 从指定索引值来删除数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 显示</span></span><br><span class="line">    show:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.owner+<span class="string">'的MP3'</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>.musicList.length;i++)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.musicList[i].songName +<span class="string">'---'</span>+<span class="keyword">this</span>.musicList[i].singer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> XiaoHong = <span class="keyword">new</span> MP3(<span class="string">'小红'</span>);  <span class="comment">// 实例小红MP3</span></span><br><span class="line"><span class="keyword">var</span> XiaoMing = <span class="keyword">new</span> MP3(<span class="string">'小明'</span>);  <span class="comment">// 实例小明MP3</span></span><br><span class="line"><span class="keyword">var</span> XiaoDong = <span class="keyword">new</span> MP3(<span class="string">'小东'</span>);  <span class="comment">// 实例小东MP3</span></span><br><span class="line"></span><br><span class="line">XiaoHong.add(<span class="string">'十年'</span>,<span class="string">'陈奕迅'</span>);          <span class="comment">// 小红的歌单里添加歌曲</span></span><br><span class="line">XiaoDong.add(<span class="string">'月亮之上'</span>,<span class="string">'凤凰传奇'</span>);    <span class="comment">// 小东的歌单里添加歌曲</span></span><br><span class="line"></span><br><span class="line">XiaoMing.musicList = [                  <span class="comment">// 小明的歌单替换</span></span><br><span class="line">    &#123;</span><br><span class="line">        songName:<span class="string">'精忠报国'</span>,</span><br><span class="line">        singer:<span class="string">'屠洪刚'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        songName:<span class="string">'窗外'</span>,</span><br><span class="line">        singer:<span class="string">'未知'</span></span><br><span class="line">    &#125;</span><br><span class="line">];</span><br><span class="line"><span class="comment">// 展示各自的歌单</span></span><br><span class="line">XiaoHong.show();        </span><br><span class="line">XiaoMing.show();</span><br><span class="line">XiaoDong.show();</span><br></pre></td></tr></table></figure>
<p><strong>打印结果：</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/9c47d583gy1fubq3m5898j20c9086aa5.jpg" alt="image"></p>
<h2 id="3-原型"><a class="header-anchor" href="#3-原型"></a>3.原型</h2>
<h3 id="3-1-传统构造函数存在问题"><a class="header-anchor" href="#3-1-传统构造函数存在问题"></a>3.1 传统构造函数存在问题</h3>
<p><strong>通过自定义构造函数的方式，创建小狗对象：</strong></p>
<blockquote>
<p>两个实例化出来的“小狗”，它们都用的同一个<code>say</code>方法，为什么最后是<code>false</code>呢？</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'汪汪汪'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> dog1 = <span class="keyword">new</span> Dog(<span class="string">'哈士奇'</span>, <span class="number">1.5</span>);</span><br><span class="line"><span class="keyword">var</span> dog2 = <span class="keyword">new</span> Dog(<span class="string">'大黄狗'</span>, <span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(dog1);</span><br><span class="line"><span class="built_in">console</span>.log(dog2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(dog1.say == dog2.say); <span class="comment">//输出结果为false</span></span><br></pre></td></tr></table></figure>
<p><strong>画个图理解下：</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/9c47d583gy1fs434nbijij20lg0ekt9b.jpg" alt="image"></p>
<p><em>每次创建一个对象的时候，都会开辟一个新的空间，我们从上图可以看出，每只创建的小狗有一个<code>say</code>方法，这个方法都是独立的，但是功能完全相同。随着创建小狗的数量增多，造成内存的浪费就更多，这就是我们需要解决的问题。</em></p>
<p><strong>为了避免内存的浪费，我们想要的其实是下图的效果：</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/9c47d583gy1fs5a5q7y6gj20nj0e53z3.jpg" alt="image"></p>
<p><strong>解决方法：</strong></p>
<blockquote>
<p>这里最好的办法就是将函数体放在构造函数之外，在构造函数中只需要引用该函数即可。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'汪汪汪'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.say = sayFn();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> dog1 = <span class="keyword">new</span> Dog(<span class="string">'哈士奇'</span>, <span class="number">1.5</span>);</span><br><span class="line"><span class="keyword">var</span> dog2 = <span class="keyword">new</span> Dog(<span class="string">'大黄狗'</span>, <span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(dog1);</span><br><span class="line"><span class="built_in">console</span>.log(dog2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(dog1.say == dog2.say); <span class="comment">//输出结果为 true</span></span><br></pre></td></tr></table></figure>
<p><strong>这样写依然存在问题：</strong></p>
<ul>
<li>全局变量增多，会增加引入框架命名冲突的风险</li>
<li>代码结构混乱，会变得难以维护</li>
</ul>
<p><em>想要解决上面的问题就需要用到<code>构造函数的原型</code>概念。</em></p>
<h3 id="3-2-原型的概念"><a class="header-anchor" href="#3-2-原型的概念"></a>3.2 原型的概念</h3>
<blockquote>
<p><code>prototype</code>：原型。每个构造函数在创建出来的时候系统会自动给这个构造函数创建并且关联一个空的对象。这个空的对象，就叫做原型。</p>
</blockquote>
<p><strong>关键点：</strong></p>
<ul>
<li>每一个由构造函数创建出来的对象，都会默认的和构造函数的原型关联；</li>
<li>当使用一个方法进行属性或者方法访问的时候，会先在当前对象内查找该属性和方法，如果当前对象内未找到，就会去跟它关联的原型对象内进行查找；</li>
<li>也就是说，在原型中定义的方法跟属性，会被这个构造函数创建出来的对象所共享；</li>
<li>访问原型的方式：<code>构造函数名.prototype</code>。</li>
</ul>
<p><strong>示例图：</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/9c47d583gy1fs7akmd4jgj20h60bbweo.jpg" alt="image"></p>
<p><strong>示例代码：</strong> 给构造函数的原型添加方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给构造函数的原型 添加say方法</span></span><br><span class="line">Dog.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'汪汪汪'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dog1 = <span class="keyword">new</span> Dog(<span class="string">'哈士奇'</span>, <span class="number">1.5</span>);</span><br><span class="line"><span class="keyword">var</span> dog2 = <span class="keyword">new</span> Dog(<span class="string">'大黄狗'</span>, <span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">dog1.say();  <span class="comment">// 汪汪汪</span></span><br><span class="line">dog2.say();  <span class="comment">// 汪汪汪</span></span><br></pre></td></tr></table></figure>
<p><em>我们可以看到，本身<code>Dog</code>这个构造函数中是没有<code>say</code>这个方法的，我们通过<code>Dog.prototype.say</code>的方式，在构造函数<code>Dog</code>的原型中创建了一个方法，实例化出来的<code>dog1</code>、<code>dog2</code>会先在自己的对象先找<code>say</code>方法，找不到的时候，会去他们的原型对象中查找。</em></p>
<p><strong>如图所示：</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/9c47d583gy1fs86or8wkij20m40gtwf5.jpg" alt="创建一个原型对象"></p>
<p><em>在构造函数的原型中可以存放所有对象共享的数据，这样可以避免多次创建对象浪费内存空间的问题。</em></p>
<h3 id="3-3-原型的使用"><a class="header-anchor" href="#3-3-原型的使用"></a>3.3 原型的使用</h3>
<p><strong>1、使用对象的动态特性</strong></p>
<blockquote>
<p>使用对象的动态属性，其实就是直接使用<code>prototype</code>为原型添加属性或者方法。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">'讲了一句话'</span> );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person.prototype.age = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br><span class="line">p.say();  <span class="comment">// 讲了一句话</span></span><br><span class="line"><span class="built_in">console</span>.log(p.age);  <span class="comment">// 18</span></span><br></pre></td></tr></table></figure>
<p><strong>2、直接替换原型对象</strong></p>
<blockquote>
<p>每次构造函数创建出来的时候，都会关联一个空对象，我们可以用一个对象替换掉这个空对象。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    say : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">'讲了一句话'</span> );</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br><span class="line">p.say();  <span class="comment">// 讲了一句话</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<blockquote>
<p>使用原型的时候，有几个注意点需要注意一下，我们通过几个案例来了解一下。</p>
</blockquote>
<ul>
<li>使用<code>对象.属性名</code>去获取对象属性的时候，会先在自身中进行查找，如果没有，就去原型中查找；</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个英雄的构造函数 它有自己的 name 和 age 属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hero</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=<span class="string">"德玛西亚之力"</span>;</span><br><span class="line">    <span class="keyword">this</span>.age=<span class="number">18</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给这个构造函数的原型对象添加方法和属性</span></span><br><span class="line">Hero.prototype.age= <span class="number">30</span>;</span><br><span class="line">Hero.prototype.say=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'人在塔在！！！'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> h1 = <span class="keyword">new</span> Hero();</span><br><span class="line">h1.say();   <span class="comment">// 先去自身中找 say 方法，没有再去原型中查找  打印：'人在塔在！！！'</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.name);  <span class="comment">// "德玛西亚之力"</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.age);   <span class="comment">// 18 先去自身中找 age 属性，有的话就不去原型中找了</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用<code>对象.属性名</code>去设置对象属性的时候，只会在自身进行查找，如果有，就修改，如果没有，就添加；</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个英雄的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hero</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=<span class="string">"德玛西亚之力"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给这个构造函数的原型对象添加方法和属性</span></span><br><span class="line">Hero.prototype.age = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> h1 = <span class="keyword">new</span> Hero();</span><br><span class="line"><span class="built_in">console</span>.log(h1);       <span class="comment">// &#123;name:"德玛西亚之力"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(h1.age);   <span class="comment">// 18</span></span><br><span class="line"></span><br><span class="line">h1.age = <span class="number">30</span>;           <span class="comment">// 设置的时候只会在自身中操作，如果有，就修改，如果没有，就添加 不会去原型中操作</span></span><br><span class="line"><span class="built_in">console</span>.log(h1);       <span class="comment">// &#123;name:"德玛西亚之力",age:30&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(h1.age);   <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>一般情况下，不会将属性放在原型中，只会将方法放在原型中；</p>
</li>
<li>
<p>在替换原型的时候，替换之前创建的对象，和替换之后创建的对象的原型不一致！！！</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个英雄的构造函数 它有自己的 name 属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hero</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=<span class="string">"德玛西亚之力"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给这个构造函数的默认原型对象添加 say 方法</span></span><br><span class="line">Hero.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'人在塔在！！！'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> h1 = <span class="keyword">new</span> Hero();</span><br><span class="line"><span class="built_in">console</span>.log(h1);    <span class="comment">// &#123;name:"德玛西亚之力"&#125;</span></span><br><span class="line">h1.say();           <span class="comment">// '人在塔在！！！'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 开辟一个命名空间 obj，里面有个 kill 方法</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    kill : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'大宝剑'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将创建的 obj 对象替换原本的原型对象</span></span><br><span class="line">Hero.prototype = obj;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> h2 = <span class="keyword">new</span> Hero();</span><br><span class="line"></span><br><span class="line">h1.say();           <span class="comment">// '人在塔在！！！'</span></span><br><span class="line">h2.say();           <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line">h1.kill();          <span class="comment">// 报错</span></span><br><span class="line">h2.kill();          <span class="comment">// '大宝剑'</span></span><br></pre></td></tr></table></figure>
<p>画个图理解下：</p>
<p><img src="http://ww1.sinaimg.cn/large/9c47d583gy1fs8hq4jgt1j20rv0hjjs5.jpg" alt="image"></p>
<p><em>图中可以看出，实例出来的<code>h1</code>对象指向的原型中，只有<code>say()</code>方法，并没有<code>kill()</code>方法，所以<code>h1.kill()</code>会报错。同理，<code>h2.say()</code>也会报错。</em></p>
<h3 id="3-4-proto-属性"><a class="header-anchor" href="#3-4-proto-属性"></a>3.4 __proto__属性</h3>
<blockquote>
<p>在<code>js</code>中以<code>_</code>开头的属性名为<code>js</code>的私有属性，以<code>__</code>开头的属性名为非标准属性。<code>__proto__</code>是一个非标准属性，最早由<code>firefox</code>提出来。</p>
</blockquote>
<p><strong>1、构造函数的 prototype 属性</strong></p>
<blockquote>
<p>之前我们访问构造函数原型对象的时候，使用的是<code>prototype</code>属性：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过构造函数的原型属性prototype可以直接访问原型</span></span><br><span class="line">Person.prototype;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在之前我们是无法通过构造函数<code>new</code>出来的对象访问原型的：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="comment">//以前不能直接通过p来访问原型对象</span></span><br></pre></td></tr></table></figure>
<p><strong>2、实例对象的 __proto__ 属性</strong></p>
<blockquote>
<p><code>__proto__</code>属性最早是火狐浏览器引入的，用以通过实例对象来访问原型，这个属性在早期是非标准的属性，有了<code>__proto__</code>属性，就可以通过构造函数创建出来的对象直接访问原型。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例对象的__proto__属性可以方便的访问到原型对象</span></span><br><span class="line">p.__proto__;</span><br><span class="line"></span><br><span class="line"><span class="comment">//既然使用构造函数的`prototype`和实例对象的`__proto__`属性都可以访问原型对象</span></span><br><span class="line"><span class="comment">//就有如下结论</span></span><br><span class="line">p.__proto__ === Person.prototype;</span><br></pre></td></tr></table></figure>
<p><strong>如图所示：</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/9c47d583gy1fs8l1aq567j20i60d53ym.jpg" alt="image"></p>
<p><strong>3、__proto__属性的用途</strong></p>
<ul>
<li>可以用来访问原型；</li>
<li>在实际开发中除非有特殊的需求，不要轻易的使用实例对象的<code>__proto__</code>属性去修改原型的属性或方法；</li>
<li>在调试过程中，可以轻易的查看原型的成员；</li>
<li>由于兼容性问题，不推荐使用。</li>
</ul>
<h3 id="3-5-constuctor属性"><a class="header-anchor" href="#3-5-constuctor属性"></a>3.5 constuctor属性</h3>
<blockquote>
<p><code>constructor</code>：构造函数，原型的<code>constructor</code>属性指向的是和原型关联的构造函数。</p>
</blockquote>
<p><strong>示例代码：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=<span class="string">"husky"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d=<span class="keyword">new</span> Dog();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取构造函数</span></span><br><span class="line"><span class="built_in">console</span>.log(Dog.prototype.constructor);  <span class="comment">// 打印构造函数 Dog</span></span><br><span class="line"><span class="built_in">console</span>.log(d.__proto__.constructor);    <span class="comment">// 打印构造函数 Dog</span></span><br></pre></td></tr></table></figure>
<p><strong>如图所示：</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/9c47d583gy1fs8m891kohj20ky0bejrq.jpg" alt="image"></p>
<p><strong>获取复杂类型的数据类型：</strong></p>
<blockquote>
<p>通过<code>obj.constructor.name</code>的方式，获取当前对象<code>obj</code>的数据类型。</p>
</blockquote>
<p><em>在一个的函数中，有个返回值<code>name</code>，它表示的是当前函数的函数名；</em></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Teacher</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> teacher = <span class="keyword">new</span> Teacher();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假使我们只知道一个对象teacher，如何获取它的类型呢？</span></span><br><span class="line"><span class="built_in">console</span>.log(teacher.__proto__.constructor.name);  <span class="comment">// Teacher</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(teacher.constructor.name);  <span class="comment">// Teacher</span></span><br></pre></td></tr></table></figure>
<p><em>实例化出来的<code>teacher</code>对象，它的数据类型是啥呢？我们可以通过实例对象<code>teacher.__proto__</code>，访问到它的原型对象，再通过<code>.constructor</code>访问它的构造函数，通过<code>.name</code>获取当前函数的函数名，所以就能得到当前对象的数据类型。又因为<code>.__proto__</code>是一个非标准的属性，而且实例出的对象继承原型对象的方法，所以直接可以写成：<code>obj.constructor.name</code>。</em></p>
<h3 id="3-6-原型继承"><a class="header-anchor" href="#3-6-原型继承"></a>3.6 原型继承</h3>
<blockquote>
<p><code>原型继承</code>：每一个构造函数都有<code>prototype</code>原型属性，通过构造函数创建出来的对象都继承自该原型属性。所以可以通过更改构造函数的原型属性来实现继承。</p>
</blockquote>
<p><em>继承的方式有多种，可以一个对象继承另一个对象，也可以通过原型继承的方式进行继承。</em></p>
<p><strong>1、简单混入继承</strong></p>
<blockquote>
<p>直接遍历一个对象，将所有的属性和方法加到另一对象上。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> animal = &#123;</span><br><span class="line">    name:<span class="string">"Animal"</span>,</span><br><span class="line">    sex:<span class="string">"male"</span>,</span><br><span class="line">    age:<span class="number">5</span>,</span><br><span class="line">    bark:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Animal bark"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dog = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> animal)&#123;</span><br><span class="line">    dog[k]= animal[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(dog);  <span class="comment">// 打印的对象与animal一模一样</span></span><br></pre></td></tr></table></figure>
<p><em>缺点：只能一个对象继承自另一个对象，代码复用太低了。</em></p>
<p><strong>2、混入式原型继承</strong></p>
<blockquote>
<p>混入式原型继承其实与上面的方法类似，只不过是将遍历的对象添加到构造函数的原型上。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">     name:<span class="string">'zs'</span>,</span><br><span class="line">     age:<span class="number">19</span>,</span><br><span class="line">     sex:<span class="string">'male'</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.weight=<span class="number">50</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> obj)&#123;</span><br><span class="line">    <span class="comment">// 将obj里面的所有属性添加到 构造函数 Person 的原型中</span></span><br><span class="line">    Person.prototype[k] = obj[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1=<span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> p2=<span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> p3=<span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1.name);  <span class="comment">// 'zs'</span></span><br><span class="line"><span class="built_in">console</span>.log(p2.age);   <span class="comment">// 19</span></span><br><span class="line"><span class="built_in">console</span>.log(p3.sex);   <span class="comment">// 'male'</span></span><br></pre></td></tr></table></figure>
<p><strong><em>面向对象思想封装一个原型继承</em></strong></p>
<blockquote>
<p>我们可以利用面向对象的思想，将面向过程进行封装。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = <span class="string">'yellow Dog'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给构造函数 Dog 添加一个方法 extend</span></span><br><span class="line">Dog.prototype.extend = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 使用混入式原型继承，给 Dog 构造函数的原型继承 obj 的属性和方法</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> obj)&#123;</span><br><span class="line">        <span class="keyword">this</span>[k]=obj[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 extend 方法</span></span><br><span class="line">Dog.prototype.extend(&#123;</span><br><span class="line">    name:<span class="string">"二哈"</span>,</span><br><span class="line">    age:<span class="string">"1.5"</span>,</span><br><span class="line">    sex:<span class="string">"公"</span>,</span><br><span class="line">    bark:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'汪汪汪'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>3、替换式原型继承</strong></p>
<blockquote>
<p>替换式原型继承，在上面已经举过例子了，其实就是将一个构造函数的原型对象替换成另一个对象。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.weight=<span class="number">50</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">    name:<span class="string">'zs'</span>,</span><br><span class="line">    age:<span class="number">19</span>,</span><br><span class="line">    sex:<span class="string">'male'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将一个构造函数的原型对象替换成另一个对象</span></span><br><span class="line">Person.prototype = obj;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1=<span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> p2=<span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> p3=<span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1.name);  <span class="comment">// 'zs'</span></span><br><span class="line"><span class="built_in">console</span>.log(p2.age);   <span class="comment">// 19</span></span><br><span class="line"><span class="built_in">console</span>.log(p3.sex);   <span class="comment">// 'male'</span></span><br></pre></td></tr></table></figure>
<p><em>之前我们就说过，这样做会产生一个问题，就是替换的对象会重新开辟一个新的空间。</em></p>
<p><strong><em>替换式原型继承时的bug</em></strong></p>
<blockquote>
<p>替换原型对象的方式会导致原型的<code>constructor</code>的丢失，<code>constructor</code>属性是默认原型对象指向构造函数的，就算是替换了默认原型对象，这个属性依旧是默认原型对象指向构造函数的，所以新的原型对象是没有这个属性的。</p>
</blockquote>
<p><img src="http://ww1.sinaimg.cn/large/9c47d583gy1fs8o69va2rj20rd0gut9r.jpg" alt="image"></p>
<p>解决方法：手动关联一个<code>constructor</code>属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.weight = <span class="number">50</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'zs'</span>,</span><br><span class="line">    age: <span class="number">19</span>,</span><br><span class="line">    sex: <span class="string">'male'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在替换原型对象函数之前 给需要替换的对象添加一个 constructor 属性 指向原本的构造函数</span></span><br><span class="line">obj.constructor = Person;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个构造函数的原型对象替换成另一个对象</span></span><br><span class="line">Person.prototype = obj;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1.__proto__.constructor === Person);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><strong>4、Object.create()方法实现原型继承</strong></p>
<blockquote>
<p>当我们想把<code>对象1</code>作为<code>对象2</code>的原型的时候，就可以实现<code>对象2</code>继承<code>对象1</code>。前面我们了解了一个属性：<code>__proto__</code>，实例出来的对象可以通过这个属性访问到它的原型，但是这个属性只适合开发调试时使用，并不能直接去替换原型对象。所以这里介绍一个新的方法：<code>Object.create()</code>。</p>
</blockquote>
<p><strong>语法：</strong> <code>var obj1 = Object.create(原型对象);</code></p>
<p><strong>示例代码：</strong> 让空对象<code>obj1</code>继承对象<code>obj</code>的属性和方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name : <span class="string">'盖伦'</span>,</span><br><span class="line">    age : <span class="number">25</span>,</span><br><span class="line">    skill : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'大宝剑'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个方法会帮我们创建一个原型是 obj 的对象</span></span><br><span class="line"><span class="keyword">var</span> obj1 = <span class="built_in">Object</span>.create(obj);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj1.name);     <span class="comment">// "盖伦"</span></span><br><span class="line">obj1.skill();               <span class="comment">// "大宝剑"</span></span><br></pre></td></tr></table></figure>
<p><strong>兼容性：</strong></p>
<blockquote>
<p>由于这个属性是<code>ECMAScript5</code>的时候提出来的，所以存在兼容性问题。</p>
</blockquote>
<p>利用浏览器的<code>能力检测</code>，如果存在<code>Object.create</code>则使用，如果不存在的话，就创建构造函数来实现原型继承。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装一个能力检测函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 判断，如果浏览器有 Object.create 方法的时候</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Object</span>.create)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.create(obj);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 创建构造函数 Fun</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">Fun</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">        Fun.prototype = obj; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Fun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hero = &#123;</span><br><span class="line">    name: <span class="string">'盖伦'</span>,</span><br><span class="line">    age: <span class="number">25</span>,</span><br><span class="line">    skill: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'大宝剑'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hero1 = create(hero);</span><br><span class="line"><span class="built_in">console</span>.log(hero1.name);    <span class="comment">// "盖伦"</span></span><br><span class="line"><span class="built_in">console</span>.log(hero1.__proto__ == hero);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="4-原型链"><a class="header-anchor" href="#4-原型链"></a>4.原型链</h2>
<blockquote>
<p>对象有原型，原型本身又是一个对象，所以原型也有原型，这样就会形成一个链式结构的原型链。</p>
</blockquote>
<h3 id="4-1-什么是原型链"><a class="header-anchor" href="#4-1-什么是原型链"></a>4.1 什么是原型链</h3>
<p><strong>示例代码：</strong> 原型继承练习</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 Animal 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.weight = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">this</span>.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'蜂蜜蜂蜜'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化一个 animal 对象</span></span><br><span class="line"><span class="keyword">var</span> animal = <span class="keyword">new</span> Animal();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 Preson 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'zs'</span>;</span><br><span class="line">    <span class="keyword">this</span>.tool = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'菜刀'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让 Person 继承 animal （替换原型对象）</span></span><br><span class="line">Person.prototype = animal;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化一个 p 对象 </span></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 Student 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.score = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">this</span>.clickCode = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'啪啪啪'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让 Student 继承 p （替换原型对象）</span></span><br><span class="line">Student.prototype = p;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化一个 student 对象</span></span><br><span class="line"><span class="keyword">var</span> student = <span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(student);           <span class="comment">// 打印 &#123;score:100,clickCode:fn&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为是一级级继承下来的 所以最上层的 Animate 里的属性也是被继承的</span></span><br><span class="line"><span class="built_in">console</span>.log(student.weight);    <span class="comment">// 50</span></span><br><span class="line">student.eat();         <span class="comment">// 蜂蜜蜂蜜</span></span><br><span class="line">student.tool();        <span class="comment">// 菜刀</span></span><br></pre></td></tr></table></figure>
<p><strong>如图所示：</strong></p>
<blockquote>
<p>我们将上面的案例通过画图的方式展现出来后就一目了然了，实例对象<code>animal</code>直接替换了构造函数<code>Person</code>的原型，以此类推，这样就会形成一个链式结构的原型链。</p>
</blockquote>
<p><img src="http://ww1.sinaimg.cn/large/9c47d583gy1fs9k7z43o6j20ob0kojs3.jpg" alt="image"></p>
<p><strong>完整的原型链</strong></p>
<blockquote>
<p>结合上图，我们发现，最初的构造函数<code>Animal</code>创建的同时，会创建出一个原型，此时的原型是一个空的对象。结合原型链的概念：“原型本身又是一个对象，所以原型也有原型”，那么这个空对象往上还能找出它的原型或者构造函数吗？</p>
</blockquote>
<p><em>我们如何创建一个空对象？ 1、字面量：<code>{}</code>；2、构造函数：<code>new Object()</code>。我们可以简单的理解为，这个空的对象就是，构造函数<code>Object</code>的实例对象。所以，这个空对象往上面找是能找到它的原型和构造函数的。</em></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 Animal 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.weight = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">this</span>.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'蜂蜜蜂蜜'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化一个 animal 对象</span></span><br><span class="line"><span class="keyword">var</span> animal = <span class="keyword">new</span> Animal();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(animal.__proto__);      <span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(animal.__proto__.__proto__);  <span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(animal.__proto__.__proto__.constructor);  <span class="comment">// function Object()&#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(animal.__proto__.__proto__.__proto__);  <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<p><strong>如图所示：</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/9c47d583gy1fs9lq5dpasj20uk0jn3zu.jpg" alt="image"></p>
<h3 id="4-2-原型链的拓展"><a class="header-anchor" href="#4-2-原型链的拓展"></a>4.2 原型链的拓展</h3>
<p><strong>1、描述出数组“[]”的原型链结构</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个数组</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们可以看到这个数组是构造函数 Array 的实例对象，所以他的原型应该是：</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype);   <span class="comment">// 打印出来还是一个空数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们可以继续往上找 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.__proto__);  <span class="comment">// 空对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.__proto__.__proto__)  <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<p><strong>如图所示：</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/9c47d583gy1fs9n5cdbapj20nr0k1jsc.jpg" alt="image"></p>
<p><strong>2、扩展内置对象</strong></p>
<blockquote>
<p>给<code>js</code>原有的内置对象，添加新的功能。</p>
</blockquote>
<p><em>注意：这里不能直接给内置对象的原型添加方法，因为在开发的时候，大家都会使用到这些内置对象，假如大家都是给内置对象的原型添加方法，就会出现问题。</em></p>
<p>错误的做法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个开发人员给 Array 原型添加了一个 say 方法</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'哈哈哈'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个开发人员也给 Array 原型添加了一个 say 方法</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'啪啪啪'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line">arr.say();  <span class="comment">// 打印 “啪啪啪”  前面写的会被覆盖</span></span><br></pre></td></tr></table></figure>
<p>为了避免出现这样的问题，只需自己定义一个构造函数，并且让这个构造函数继承数组的方法即可，再去添加新的方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个数组对象 这个数组对象继承了所有数组中的方法</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个属于自己的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyArray</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只需要将自己创建的构造函数的原型替换成 数组对象，就能继承数组的所有方法</span></span><br><span class="line">MyArray.prototype = arr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在可以单独的给自己创建的构造函数的原型添加自己的方法</span></span><br><span class="line">MyArray.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'这是我自己添加的say方法'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr1 = <span class="keyword">new</span> MyArray();</span><br><span class="line"></span><br><span class="line">arr1.push(<span class="number">1</span>);   <span class="comment">// 创建的 arr1 对象可以使用数组的方法</span></span><br><span class="line">arr1.say();     <span class="comment">// 也可以使用自己添加的方法  打印“这是我自己添加的say方法”</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1);  <span class="comment">// [1]</span></span><br></pre></td></tr></table></figure>
<h3 id="4-3-属性的搜索原则"><a class="header-anchor" href="#4-3-属性的搜索原则"></a>4.3 属性的搜索原则</h3>
<blockquote>
<p>当通过<code>对象名.属性名</code>获取属性时，会遵循以下属性搜索的原则：</p>
</blockquote>
<ul>
<li>1-首先去对象自身属性中找，如果找到直接使用，</li>
<li>2-如果没找到，去自己的原型中找，如果找到直接使用，</li>
<li>3-如果没找到，去原型的原型中继续找，找到直接使用，</li>
<li>4-如果没有会沿着原型不断向上查找，直到找到<code>null</code>为止。</li>
</ul>
<h2 id="5-object-prototype成员介绍"><a class="header-anchor" href="#5-object-prototype成员介绍"></a>5.Object.prototype成员介绍</h2>
<blockquote>
<p>我们可以看到所有的原型最终都会继承<code>Object</code>的原型：<code>Object.prototype</code>。</p>
</blockquote>
<p>打印看看<code>Object</code>的原型里面有什么：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object的原型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype)</span><br></pre></td></tr></table></figure>
<p>如图所示：</p>
<p><img src="http://ww1.sinaimg.cn/large/9c47d583gy1fsaigizhd8j20at070t8x.jpg" alt="image"></p>
<p><em>我们可以看到<code>Object</code>的原型里有很多方法，下面就来介绍下这些方法的作用。</em></p>
<h3 id="5-1-constructor-属性"><a class="header-anchor" href="#5-1-constructor-属性"></a>5.1 constructor 属性</h3>
<blockquote>
<p>指向了和原型相关的构造函数</p>
</blockquote>
<h3 id="5-2-hasownproperty-方法"><a class="header-anchor" href="#5-2-hasownproperty-方法"></a>5.2 hasOwnProperty 方法</h3>
<blockquote>
<p>判断对象自身是否拥有某个属性，返回值：<code>布尔类型</code>。</p>
</blockquote>
<p><strong>示例代码：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hero</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'盖伦'</span>;</span><br><span class="line">    <span class="keyword">this</span>.age = <span class="string">'25'</span>;</span><br><span class="line">    <span class="keyword">this</span>.skill = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'盖伦使用了大宝剑'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hero = <span class="keyword">new</span> Hero();</span><br><span class="line"><span class="built_in">console</span>.log(hero.name); <span class="comment">// '盖伦'</span></span><br><span class="line">hero.skill();           <span class="comment">// '盖伦使用了大宝剑'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(hero.hasOwnProperty(<span class="string">"name"</span>));       <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(hero.hasOwnProperty(<span class="string">"age"</span>));        <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(hero.hasOwnProperty(<span class="string">"skill"</span>));      <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(hero.hasOwnProperty(<span class="string">"toString"</span>));   <span class="comment">// false toString是在原型链当中的方法，并不是这里对象的方法</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'toString'</span> <span class="keyword">in</span> hero); <span class="comment">// true in方法 判断对象自身或者原型链中是否有某个属性</span></span><br></pre></td></tr></table></figure>
<h3 id="5-3-isprototypeof-方法"><a class="header-anchor" href="#5-3-isprototypeof-方法"></a>5.3 isPrototypeOf 方法</h3>
<blockquote>
<p><code>对象1.isPrototypeOf(对象2)</code>，判断<code>对象1</code>是否是<code>对象2</code>的原型，或者<code>对象1</code>是否是<code>对象2</code>原型链上的原型。</p>
</blockquote>
<p><strong>示例代码：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hero</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'盖伦'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将这个构造函数的原型替换成 obj</span></span><br><span class="line">Hero.prototype = obj;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化一个 hero 对象</span></span><br><span class="line"><span class="keyword">var</span> hero = <span class="keyword">new</span> Hero();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.isPrototypeOf(hero));   <span class="comment">// true  判断 obj 是否是 hero 的原型</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.isPrototypeOf(hero));  <span class="comment">// false  判断 obj1 是否是 hero 的原型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.isPrototypeOf(hero));  <span class="comment">// true  判断 Object.prototype 是否是 hero 的原型</span></span><br><span class="line"><span class="comment">// 注意 这里的 Object.prototype 是原型链上最上层的原型对象</span></span><br></pre></td></tr></table></figure>
<h3 id="5-4-propertyisenumerable-方法"><a class="header-anchor" href="#5-4-propertyisenumerable-方法"></a>5.4 propertyIsEnumerable 方法</h3>
<blockquote>
<p><code>对象.propertyIsEnumerable('属性或方法名')</code>，判断一个对象是否有该属性，并且这个属性可以被<code>for-in</code>遍历，返回值：<code>布尔类型</code>。</p>
</blockquote>
<p><strong>示例代码：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hero</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'盖伦'</span>;</span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">25</span>;</span><br><span class="line">    <span class="keyword">this</span>.skill = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'盖伦使用了大宝剑'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个对象</span></span><br><span class="line"><span class="keyword">var</span> hero = <span class="keyword">new</span> Hero();</span><br><span class="line"></span><br><span class="line"><span class="comment">// for-in 遍历这个对象 我们可以看到分别打印了哪些属性和方法</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> hero)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(k + <span class="string">'—'</span> + hero[k]); <span class="comment">// "name-盖伦" "age-25" "skill-fn()"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断一个对象是否有该属性，并且这个属性可以被 for-in 遍历</span></span><br><span class="line"><span class="built_in">console</span>.log(hero.propertyIsEnumerable(<span class="string">'name'</span>));     <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(hero.propertyIsEnumerable(<span class="string">'age'</span>));      <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(hero.propertyIsEnumerable(<span class="string">'test'</span>));     <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="5-5-tostring-和-tolocalstring-方法"><a class="header-anchor" href="#5-5-tostring-和-tolocalstring-方法"></a>5.5 toString 和 toLocalString 方法</h3>
<blockquote>
<p>两种方法都是将对象转成字符串的，只不过<code>toLocalString</code>是按照本地格式进行转换。</p>
</blockquote>
<p><strong>示例代码：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 举个例子，时间的格式可以分为世界时间的格式和电脑本地的时间格式</span></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接将创建的时间对象转换成字符串</span></span><br><span class="line"><span class="built_in">console</span>.log(date.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将创建的时间对象按照本地格式进行转换</span></span><br><span class="line"><span class="built_in">console</span>.log(date.toLocaleString());</span><br></pre></td></tr></table></figure>
<p><strong>效果图：</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/9c47d583gy1fsanzoq584j20b901d743.jpg" alt="image"></p>
<h3 id="5-6-valueof-方法"><a class="header-anchor" href="#5-6-valueof-方法"></a>5.6 valueOf 方法</h3>
<blockquote>
<p>返回指定对象的原始值。</p>
</blockquote>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf" target="_blank" rel="noopener">MDN官方文档</a></p>
<h2 id="6-静态方法和实例方法"><a class="header-anchor" href="#6-静态方法和实例方法"></a>6.静态方法和实例方法</h2>
<blockquote>
<p>静态方法和实例方法这两个概念其实也是从面相对象的编程语言中引入的，对应到<code>JavaScript</code>中的理解为：</p>
</blockquote>
<p><strong>静态方法：</strong> 由构造函数调用的</p>
<blockquote>
<p>在<code>js</code>中，我们知道有个<code>Math</code>构造函数，他有一个<code>Math.abs()</code>的方法，这个方法由构造函数调用，所以就是静态方法。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.abs();</span><br></pre></td></tr></table></figure>
<p><strong>实例方法：</strong> 由构造函数创建出来的对象调用的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由构造函数 Array 实例化出来的对象 arr 调用的 push 方法，叫做实例方法</span></span><br><span class="line">arr.push(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p><strong>示例代码：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hero</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=<span class="string">'亚索'</span>;</span><br><span class="line">    <span class="keyword">this</span>.say=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'哈撒ki'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Hero.prototype.skill=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'吹风'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接给构造函数添加一个 run 方法（函数也是对象，可以直接给它加个方法）</span></span><br><span class="line">Hero.run=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'死亡如风,常伴吾身'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hero = <span class="keyword">new</span> Hero();</span><br><span class="line"></span><br><span class="line">hero.say();</span><br><span class="line">hero.skill();   <span class="comment">//实例方法</span></span><br><span class="line"></span><br><span class="line">Hero.run();     <span class="comment">//静态方法</span></span><br></pre></td></tr></table></figure>
<p><em>如果这个方法是对象所有的，用实例方法。一般的工具函数，用静态方法，直接给构造函数添加方法，不需要实例化，通过构造函数名直接使用即可；</em></p>
<h2 id="7-作用域"><a class="header-anchor" href="#7-作用域"></a>7.作用域</h2>
<blockquote>
<p>“域”，表示的是一个范围，“作用域”就是作用范围。作用域说明的是一个变量可以在什么地方被使用，什么地方不能被使用。</p>
</blockquote>
<h3 id="7-1-块级作用域"><a class="header-anchor" href="#7-1-块级作用域"></a>7.1 块级作用域</h3>
<blockquote>
<p>在<code>ES5</code>及<code>ES5</code>之前，<code>js</code>中是没有块级作用域的。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">123</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">console</span>.log( num ); <span class="comment">// 123</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log( num ); <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>
<p>上面这段代码在<code>JavaScript</code>中是不会报错的，但是在其他的编程语言中<code>（C#、C、JAVA）</code>会报错。这是因为，在<code>JavaScript</code>中没有块级作用域，使用<code>{}</code>标记出来的代码块中声明的变量<code>num</code>，是可以被<code>{}</code>外面访问到的。但是在其他的编程语言中，有块级作用域，那么<code>{}</code>中声明的变量<code>num</code>，是不能在代码块外部访问的，所以报错。</p>
<p><em>注意：会计作用域只在在<code>ES5</code>及<code>ES5</code>之前不起作用，但是在<code>ES6</code>开始，<code>js</code>中是存在块级作用域的。</em></p>
<h3 id="7-2-词法作用域"><a class="header-anchor" href="#7-2-词法作用域"></a>7.2 词法作用域</h3>
<blockquote>
<p>词法( 代码 )作用域，就是代码在编写过程中体现出来的作用范围。代码一旦写好，不用执行，作用范围就已经确定好了，这个就是所谓词法作用域。</p>
</blockquote>
<p><strong>在<code>js</code>中词法作用域规则:</strong></p>
<ul>
<li>函数允许访问函数外的数据；</li>
<li>整个代码结构中只有函数可以限定作用域；</li>
<li>作用域规则首先使用提升规则分析；</li>
<li>如果当前作用规则中有名字了，就不考虑外面的名字。</li>
</ul>
<p><strong>作用域练习：</strong></p>
<p>第一题</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num=<span class="number">250</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 会现在函数内部查找有没有这个num变量，有的话调用，没有的话会去全局中查找，有就返回，没有就返回undefined</span></span><br><span class="line">    <span class="built_in">console</span>.log(num);  <span class="comment">// 打印 250</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> num=<span class="number">222</span>;</span><br><span class="line">   test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test1();</span><br></pre></td></tr></table></figure>
<p>第二题</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">false</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// undefined </span></span><br><span class="line"><span class="comment">// &#123;&#125;是没有作用域的 但是有判断条件，var num会提升到判断语句外部 所以不会报错 打印的是undefined</span></span><br></pre></td></tr></table></figure>
<p>第三题</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">123</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">456</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( num );</span><br><span class="line">    &#125;</span><br><span class="line">    func();</span><br><span class="line">&#125;</span><br><span class="line">foo();  <span class="comment">// 456</span></span><br><span class="line"><span class="comment">// 调用foo时，在函数内部调用了func，打印num的时候，会先在func中查找num  没有的时候会去外层作用域找，找到即返回，找不到即再往上找。</span></span><br></pre></td></tr></table></figure>
<p>第四题</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="number">123</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> num1 = <span class="number">456</span>;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">foo2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       num1 = <span class="number">789</span>;</span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">foo3</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">           <span class="built_in">console</span>.log( num1 );  <span class="comment">// 789  自己的函数作用域中没有就一层层往上找</span></span><br><span class="line">       &#125;</span><br><span class="line">       foo3();</span><br><span class="line">   &#125;</span><br><span class="line">   foo2();</span><br><span class="line">&#125;</span><br><span class="line">foo1();</span><br><span class="line"><span class="built_in">console</span>.log( num1 ); <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>
<h3 id="7-3-变量提升-预解析"><a class="header-anchor" href="#7-3-变量提升-预解析"></a>7.3 变量提升（预解析）</h3>
<blockquote>
<p><code>JavaScript</code>是解释型的语言，但是它并不是真的在运行的时候逐句的往下解析执行。</p>
</blockquote>
<p>我们来看下面这个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"函数被调用了"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面这段代码中，函数<code>func</code>的调用是在其声明之前，如果说<code>JavaScript</code>代码真的是逐句的解析执行，那么在第一句调用的时候就会出错，然而事实并非如此，上面的代码可以正常执行，并且<code>alert</code>出来&quot;函数被调用了&quot;。</p>
<p><em>所以，可以得出结论，<code>JavaScript</code>并非仅在运行时简简单单的逐句解析执行！</em></p>
<p><strong>JavaScript预解析</strong></p>
<blockquote>
<p><code>JavaScript</code>引擎在对<code>JavaScript</code>代码进行解释执行之前，会对<code>JavaScript</code>代码进行预解析，在预解析阶段，会将以关键字<code>var</code>和<code>function</code>开头的语句块提前进行处理。</p>
</blockquote>
<p><em>关键问题是怎么处理呢？</em></p>
<ul>
<li>当变量和函数的声明处在作用域比较靠后的位置的时候，变量和函数的声明会被提升到当前作用域的开头。</li>
</ul>
<p><strong>示例代码：函数名提升</strong></p>
<ul>
<li>正常函数书写方式</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"函数被调用了"</span>);</span><br><span class="line">&#125;</span><br><span class="line">func();</span><br></pre></td></tr></table></figure>
<ul>
<li>预解析之后，函数名提升</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"函数被调用了"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>示例代码：变量名提升</strong></p>
<ul>
<li>正常变量书写方式</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert(a);  <span class="comment">// undefined  </span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">123</span>;</span><br><span class="line"><span class="comment">// 由于JavaScript的预解析机制，上面这段代码，alert出来的值是undefined，</span></span><br><span class="line"><span class="comment">// 如果没有预解析，代码应该会直接报错a is not defined，而不是输出值。</span></span><br></pre></td></tr></table></figure>
<ul>
<li>不是说要提前的吗？那不是应该<code>alert</code>出来<code>123</code>，为什么是<code>undefined</code>?</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量的时候 提升的只是变量声明的提升，并不包括赋值</span></span><br><span class="line"><span class="keyword">var</span> a;      <span class="comment">// 这里是声明</span></span><br><span class="line">alert(a);   <span class="comment">// 变量声明之后并未有初始化和赋值操作，所以这里是 undefined</span></span><br><span class="line">a = <span class="number">123</span>;    <span class="comment">// 这里是赋值</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：特殊情况</strong></p>
<p>1、函数不能被提升的情况</p>
<ul>
<li>函数表达式创建的函数不会提升</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test();   <span class="comment">// 报错 "test is not a function"</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">123</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>new Function</code>创建的函数也不会被提升</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test();   <span class="comment">// 报错 "test is not a function"</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="keyword">new</span> <span class="built_in">Function</span>()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">123</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、出现同名函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">test();  <span class="comment">// 打印 '好走的都是下坡路'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个函数重名，这两个函数都会被提升，但是后面的函数会覆盖掉前面的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'众里寻她千百度，他正在自助烤肉....'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'好走的都是下坡路'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、函数名与变量名同名</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果函数和变量重名，只会提升函数，变量不会被提升</span></span><br><span class="line"><span class="built_in">console</span>.log(test);  <span class="comment">// 打印这个test函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'我是test'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> test=<span class="number">200</span>;</span><br></pre></td></tr></table></figure>
<p>再看一种情况：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">num</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num); <span class="comment">// 报错 “num is not a function”</span></span><br><span class="line">&#125;</span><br><span class="line">num();</span><br></pre></td></tr></table></figure>
<p>直接上预解析后的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">num</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">num = <span class="number">1</span>;</span><br><span class="line">num();</span><br></pre></td></tr></table></figure>
<p>4、条件式的函数声明</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果是条件式的函数申明， 这个函数不会被预解析</span></span><br><span class="line">test();  <span class="comment">// test is not a function</span></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'只是在人群中多看了我一眼，再也忘不掉我容颜...'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>预解析是分作用域的</strong></p>
<blockquote>
<p>声明提升并不是将所有的声明都提升到<code>window</code> 对象下面，提升原则是提升到变量运行的当前作用域中去。</p>
</blockquote>
<p>示例代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showMsg</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> msg = <span class="string">'This is message'</span>;</span><br><span class="line">&#125;</span><br><span class="line">alert(msg); <span class="comment">// 报错“Uncaught ReferenceError: msg is not defined”</span></span><br></pre></td></tr></table></figure>
<p>预解析之后：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showMsg</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> msg;    <span class="comment">// 因为函数本身就会产生一个作用域，所以变量声明在提升的时候，只会提升在当前作用域下最前面</span></span><br><span class="line">    msg = <span class="string">'This is message'</span>;</span><br><span class="line">&#125;</span><br><span class="line">alert(msg); <span class="comment">// 报错“Uncaught ReferenceError: msg is not defined”</span></span><br></pre></td></tr></table></figure>
<p><strong>预解析是分段的</strong></p>
<blockquote>
<p>分段，其实就分<code>script</code>标签的</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">func(); <span class="comment">// 输出 AA2;</span></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'AA1'</span>);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'AA2'</span>);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'AA3'</span>);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面代码中，第一个<code>script</code>标签中的两个<code>func</code>进行了提升，第二个<code>func</code>覆盖了第一个<code>func</code>，但是第二个<code>script</code>标签中的<code>func</code>并没有覆盖上面的第二个<code>func</code>。所以说预解析是分段的。</p>
<p><strong>tip:</strong> 但是要注意，分段只是单纯的针对函数，变量并不会分段预解析。</p>
<p>函数预解析的时候是分段的，但是执行的时候不分段</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">//变量预解析是分段的 ，但是函数的执行是不分段</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> num1=<span class="number">100</span>;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// test3();  报错，函数预解析的时候分段，执行的时候才不分段</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'我是test1'</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'我是test2'</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> num2=<span class="number">200</span>;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">test3</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'test3'</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    test1();   <span class="comment">// 打印 '我是test1' 函数执行的时候不分段</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(num1); <span class="comment">// 100</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="7-4-作用域链"><a class="header-anchor" href="#7-4-作用域链"></a>7.4 作用域链</h3>
<p><strong>什么是作用域链？</strong></p>
<blockquote>
<p>只有函数可以制造作用域结构，那么只要是代码，就至少有一个作用域, 即全局作用域。</p>
</blockquote>
<p><em>凡是代码中有函数，那么这个函数就构成另一个作用域。如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域。将这样的所有的作用域列出来，可以有一个结构: 函数内指向函数外的链式结构。就称作作用域链。</em></p>
<p><strong>例如：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">456</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f4</span>(<span class="params"></span>) </span>&#123;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>示例代码：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num=<span class="number">200</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num=<span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> num=<span class="number">50</span>;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(num);</span><br><span class="line">        &#125;</span><br><span class="line">        test2();</span><br><span class="line">    &#125;</span><br><span class="line">    test1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();   <span class="comment">// 打印 “50”</span></span><br></pre></td></tr></table></figure>
<p><strong>如图所示：</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/9c47d583gy1fukvin4gi7j20vo0c2750.jpg" alt="image"></p>
<p><strong>绘制作用域链的步骤：</strong></p>
<ul>
<li>看整个全局是一条链, 即顶级链, 记为<code>0</code>级链</li>
<li>看全局作用域中, 有什么变量和函数声明, 就以方格的形式绘制到<code>0</code>级练上</li>
<li>再找函数, 只有函数可以限制作用域, 因此从函数中引入新链, 标记为<code>1</code>级链</li>
<li>然后在每一个<code>1</code>级链中再次往复刚才的行为</li>
</ul>
<p><strong>变量的访问规则：</strong></p>
<ul>
<li>首先看变量在第几条链上, 在该链上看是否有变量的定义与赋值, 如果有直接使用</li>
<li>如果没有到上一级链上找<code>( n - 1 级链 )</code>, 如果有直接用, 停止继续查找.</li>
<li>如果还没有再次往上刚找… 直到全局链( <code>0</code> 级 ), 还没有就是 <code>is not defined</code></li>
<li>注意,同级的链不可混合查找</li>
</ul>
<p><strong>来点案例练练手</strong></p>
<p>第一题:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">123</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(num); <span class="comment">//123</span></span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<p>第二题:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"global"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(scope); <span class="comment">//  undefined</span></span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">"local"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(scope); <span class="comment">// 'local'</span></span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预解析之后</span></span><br><span class="line"><span class="comment">// var scope = "global";</span></span><br><span class="line"><span class="comment">// function foo() &#123;</span></span><br><span class="line"><span class="comment">//   var scope;</span></span><br><span class="line"><span class="comment">//   console.log(scope); // undefined</span></span><br><span class="line"><span class="comment">//   scope = "local";</span></span><br><span class="line"><span class="comment">//   console.log(scope); // local</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<p>第三题:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="string">"a"</span> <span class="keyword">in</span> <span class="built_in">window</span>)&#123;</span><br><span class="line">   <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 预解析之后</span></span><br><span class="line"><span class="comment">// var a;</span></span><br><span class="line"><span class="comment">// if("a" in window)&#123;</span></span><br><span class="line"><span class="comment">//    a = 10;        // 判断语句不产生作用域</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// console.log(a); // 10</span></span><br></pre></td></tr></table></figure>
<p>第四题:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!<span class="string">"a"</span> <span class="keyword">in</span> <span class="built_in">window</span>)&#123;</span><br><span class="line">   <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 预解析之后</span></span><br><span class="line"><span class="comment">// var a;</span></span><br><span class="line"><span class="comment">// if(!"a" in window)&#123;</span></span><br><span class="line"><span class="comment">//    a = 10;        // 判断语句不产生作用域</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// console.log(a); // undefined</span></span><br></pre></td></tr></table></figure>
<p>第五题</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// console.log(num); 报错 虽然num是全局变量 但是不会提升</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   num = <span class="number">100</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num);   <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>
<p>第六题</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(!foo) &#123;</span><br><span class="line">       <span class="keyword">var</span> foo = <span class="number">10</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">console</span>.log(foo); <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br><span class="line">bar();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预解析之后</span></span><br><span class="line"><span class="comment">// var foo=1;</span></span><br><span class="line"><span class="comment">// function bar()&#123;</span></span><br><span class="line"><span class="comment">//    var foo;</span></span><br><span class="line"><span class="comment">//    if(!foo)&#123;</span></span><br><span class="line"><span class="comment">//        foo=10;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    console.log(foo); // 10</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// bar();</span></span><br></pre></td></tr></table></figure>
<h2 id="8-function"><a class="header-anchor" href="#8-function"></a>8.Function</h2>
<blockquote>
<p><code>Function</code>是函数的构造函数，你可能会有点蒙圈，没错，在<code>js</code>中函数与普通的对象一样，也是一个对象类型，只不过函数是<code>js</code>中的“一等公民”。</p>
</blockquote>
<p><em>这里的<code>Function</code>类似于<code>Array</code>、<code>Object</code>等</em></p>
<h3 id="8-1-创建函数的几种方式"><a class="header-anchor" href="#8-1-创建函数的几种方式"></a>8.1 创建函数的几种方式</h3>
<p><strong>1、函数字面量（直接声明函数）创建方式</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;   </span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;   <span class="comment">// 类似于对象字面量创建方式：&#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>2、函数表达式</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3、Function构造函数创建</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数创建一个空的函数</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">new</span> <span class="built_in">Function</span>();</span><br><span class="line">fn1();  <span class="comment">// 调用函数</span></span><br></pre></td></tr></table></figure>
<p><strong><em>函数扩展名</em></strong></p>
<blockquote>
<p>有没有一种可能，函数表达式声明函数时，<code>function</code> 也跟着一个函数名，如：<code>var fn = function fn1(){}</code>？ 答案是可以的，不过<code>fn1</code>只能在函数内部使用，并不能在外部调用。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">a,b,c,d</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'当前函数被调用了'</span>);</span><br><span class="line">    <span class="comment">// 但是，fn1可以在函数的内部使用</span></span><br><span class="line">    <span class="built_in">console</span>.log(fn1.name);</span><br><span class="line">    <span class="built_in">console</span>.log(fn1.length);</span><br><span class="line">    <span class="comment">// fn1();  注意，这样调用会引起递归！！！  下面我们会讲到什么是递归。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// fn1();   // 报错，fn1是不能在函数外部调用的</span></span><br><span class="line">fn();   <span class="comment">// "当前函数被调用了"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数内部使用时打印：</span></span><br><span class="line"><span class="comment">// "当前函数被调用了"</span></span><br><span class="line"><span class="comment">// console.log(fn1.name); =&gt; "fn1"</span></span><br><span class="line"><span class="comment">// console.log(fn1.length); =&gt; 4</span></span><br></pre></td></tr></table></figure>
<h3 id="8-2-function-构造函数创建函数"><a class="header-anchor" href="#8-2-function-构造函数创建函数"></a>8.2 Function 构造函数创建函数</h3>
<blockquote>
<p>上面我们知道了如何通过<code>Function</code>构造函数创建一个空的函数，这里我们对它的传参详细的说明下。</p>
</blockquote>
<p><strong>1、不传参数时</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不传参数时，创建的是一个空的函数</span></span><br><span class="line"><span class="keyword">var</span> fn1 = <span class="keyword">new</span> <span class="built_in">Function</span>();</span><br><span class="line">fn1();  <span class="comment">// 调用函数</span></span><br></pre></td></tr></table></figure>
<p><strong>2、只传一个参数</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只传一个参数的时候，这个参数就是函数体</span></span><br><span class="line"><span class="comment">// 语法：var fn = new Function(函数体);</span></span><br><span class="line"><span class="keyword">var</span> fn2 = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'console.log(2+5)'</span>);</span><br><span class="line">f2();   <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>
<p><strong>3、传多个参数</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传多个参数的时候，最后一个参数为函数体，前面的参数都是函数的形参名</span></span><br><span class="line"><span class="comment">// 语法：var fn = new Function(arg1,arg2,arg3.....argn,metthodBody);</span></span><br><span class="line"><span class="keyword">var</span> fn3 = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'num1'</span>,<span class="string">'num2'</span>,<span class="string">'console.log(num1+num2)'</span>);</span><br><span class="line">f3(<span class="number">5</span>,<span class="number">2</span>);   <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>
<h3 id="8-3-function-的使用"><a class="header-anchor" href="#8-3-function-的使用"></a>8.3 Function 的使用</h3>
<p><strong>1、用<code>Function</code>创建函数的方式封装一个计算<code>m - n</code>之间所有数字的和的函数</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求 m-n之间所有数字的和</span></span><br><span class="line"><span class="comment">//var sum=0;</span></span><br><span class="line"><span class="comment">//for (var i = m; i &lt;=n; i++) &#123;</span></span><br><span class="line"><span class="comment">//  sum+=i;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'m'</span>,<span class="string">'n'</span>,<span class="string">'var sum=0;for (var i = m; i &lt;=n; i++) &#123;sum+=i;&#125; console.log(sum);'</span>);</span><br><span class="line">fn(<span class="number">1</span>,<span class="number">100</span>);  <span class="comment">// 5050</span></span><br></pre></td></tr></table></figure>
<p><strong>函数体参数过长问题：</strong></p>
<blockquote>
<p>函数体过长时，可读性很差，所以介绍解决方法：</p>
</blockquote>
<p>1）字符串拼接符“<code>+</code>”</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="keyword">new</span> <span class="built_in">Function</span>(</span><br><span class="line">    <span class="string">'m'</span>,</span><br><span class="line">    <span class="string">'n'</span>,</span><br><span class="line">    <span class="string">'var sum=0;'</span>+</span><br><span class="line">    <span class="string">'for (var i = m; i &lt;=n; i++) &#123;'</span>+</span><br><span class="line">        <span class="string">'sum += i;'</span>+</span><br><span class="line">    <span class="string">'&#125;'</span>+</span><br><span class="line">    <span class="string">'console.log(sum);'</span></span><br><span class="line">    );</span><br><span class="line">fn(<span class="number">1</span>,<span class="number">100</span>);  <span class="comment">// 5050</span></span><br></pre></td></tr></table></figure>
<p>2）<code>ES6</code>中新语法“ ` ”，(在<code>esc</code>键下面)</p>
<blockquote>
<p>表示可换行字符串的界定符，之前我们用的是单引号或者双引号来表示一个字符串字面量，在<code>ES6</code>中可以用反引号来表示该字符串可换行。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Function</span>(</span><br><span class="line">    <span class="string">'m'</span>,</span><br><span class="line">    <span class="string">'n'</span>,</span><br><span class="line">    <span class="string">`var sum=0;</span></span><br><span class="line"><span class="string">    for (var i = m; i &lt;=n; i++) &#123;</span></span><br><span class="line"><span class="string">        sum+=i;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    console.log(sum);`</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>3）模板方式</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 新建一个模板 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/template"</span> <span class="attr">id</span>=<span class="string">"tmp"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> sum=<span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span> (<span class="keyword">var</span> i = m; i &lt;=n; i++) &#123;</span></span><br><span class="line"><span class="undefined">        sum += i;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(sum);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 获取模板内的内容</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> methodBody = <span class="built_in">document</span>.querySelector(<span class="string">'#tmp'</span>).innerHTML;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(methodBody);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> fn = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'m'</span>,<span class="string">'n'</span>,methodBody);</span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="javascript">    fn(<span class="number">2</span>,<span class="number">6</span>);  <span class="comment">// 20</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>2、eval 函数</strong></p>
<blockquote>
<p><code>eval</code>函数可以直接将把字符串的内容，作为<code>js</code>代码执行，前提是字符串代码符合<code>js</code>代码规范。这里主要是用作跟<code>Function</code>传参比较。</p>
</blockquote>
<p><strong><code>eval</code> 和 <code>Function</code> 的区别：</strong></p>
<ul>
<li><code>Function();</code>中，方法体是字符串，必须调用这个函数才能执行</li>
<li><code>eval();</code> 可以直接执行字符串中的<code>js</code>代码</li>
</ul>
<p><strong>存在的问题：</strong></p>
<ul>
<li>性能问题</li>
</ul>
<blockquote>
<p>因为<code>eval</code>里面的代码是直接执行的，所以当在里面定义一个变量的时候，这个变量是不会预解析的，所以会影响性能。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eval 里面的代码可以直接执行，所以下面的打印的 num 可以访问到它</span></span><br><span class="line"><span class="comment">// 但是这里定义的 num 是没有预解析的，所以变量名不会提升，从而性能可能会变慢</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">'var num = 123;'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(num);   <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>
<ul>
<li>安全问题</li>
</ul>
<blockquote>
<p>主要的安全问题是可能会被利用做<code>XSS</code>攻击（跨站脚本攻击(<code>Cross Site Scripting</code>)），<code>eval</code>也存在一个安全问题，因为它可以执行传给它的任何字符串，所以永远不要传入字符串或者来历不明和不受信任源的参数。</p>
</blockquote>
<p><strong>示例代码：</strong> 实现一个简单的计算器</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- html 部分 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"num1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">class</span>=<span class="string">"operator"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"+"</span>&gt;</span>+<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"-"</span>&gt;</span>-<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"*"</span>&gt;</span>*<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"/"</span>&gt;</span>/<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"num2"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>=<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"result"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- js 部分 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.querySelector(<span class="string">'button'</span>).onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> num1 = <span class="built_in">document</span>.querySelector(<span class="string">'.num1'</span>).value;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> num2 = <span class="built_in">document</span>.querySelector(<span class="string">'.num2'</span>).value;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> operator = <span class="built_in">document</span>.querySelector(<span class="string">'.operator'</span>).value;</span></span><br><span class="line"><span class="undefined">        </span></span><br><span class="line"><span class="javascript">        <span class="comment">// result其实最终获得的就是 num1 + operator + num2的字符串  但是他能够直接执行并计算</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> result = <span class="built_in">eval</span>(num1 + operator + num2);          <span class="comment">//计算</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.querySelector(<span class="string">'.result'</span>).value = result;   <span class="comment">//显示</span></span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>效果图：</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/9c47d583gy1fstap8w0rhg20hm040glp.gif" alt="image"></p>
<h3 id="8-4-function-的原型链结构"><a class="header-anchor" href="#8-4-function-的原型链结构"></a>8.4 Function 的原型链结构</h3>
<blockquote>
<p>在<code>7.2</code>章节中我们知道函数也还可以通过构造函数的方式创建出来，既然可以通过构造函数的方式创建，那么函数本身也是有原型对象的。</p>
</blockquote>
<p><strong>示例代码：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过Function构造函数创建一个函数test</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="keyword">new</span> <span class="built_in">Function</span>();</span><br><span class="line"><span class="comment">// 既然是通过构造函数创建的，那么这个函数就有指向的原型</span></span><br><span class="line"><span class="built_in">console</span>.log(test.__proto__);  <span class="comment">// 打印出来的原型是一个空的函数</span></span><br><span class="line"><span class="built_in">console</span>.log(test.__proto__.__proto__);  <span class="comment">// 空的函数再往上找原型是一个空的对象</span></span><br><span class="line"><span class="built_in">console</span>.log(test.__proto__.__proto__.__proto__);    <span class="comment">// 再往上找就是null了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数原型链： test() ---&gt; Function.prototype ---&gt; Object.prototype ---&gt; null</span></span><br></pre></td></tr></table></figure>
<p><strong>如图所示：</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/9c47d583gy1ft1brlihecj20jz0ilq3d.jpg" alt="image"></p>
<p><em>通过上图，可以直观的看出，函数也是有原型的。那一个完整的原型链究竟是什么样子的呢？下面我们一起做个总结。</em></p>
<h3 id="8-5-完整的原型链"><a class="header-anchor" href="#8-5-完整的原型链"></a>8.5 完整的原型链</h3>
<p><strong>绘制完整原型链的步骤：</strong></p>
<ul>
<li>1、先将一个对象的原型画出来</li>
<li>2、再把对象的原型的原型链画出来 ，到<code>null</code>结束</li>
<li>3、把对象的构造函数的原型链画出来</li>
<li>4、把<code>Function</code>和<code>Object</code>的原型关系给画出来</li>
</ul>
<p><strong>示例代码：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'Levi'</span>;</span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">18</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化一个对象</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>
<p><strong>如图所示：</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/9c47d583gy1ftpj11xvzbj20zh0m1abu.jpg" alt="image"></p>
<p><strong>总结：</strong></p>
<ul>
<li><code>Function</code>构造函数的原型，在<code>Object</code>的原型链上；</li>
<li><code>Object</code>构造函数的原型，在<code>Function</code>的原型链上；</li>
</ul>
<h2 id="9-arguments对象"><a class="header-anchor" href="#9-arguments对象"></a>9.arguments对象</h2>
<blockquote>
<p>在每一个函数调用的过程中, 函数代码体内有一个默认的对象<code>arguments</code>, 它存储着实际传入的所有参数。</p>
</blockquote>
<p><strong>示例代码：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装一个加法函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num1+num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>);     <span class="comment">// NaN</span></span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>);   <span class="comment">// 3</span></span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p><em>在调用函数时，实参和形参的个数可以不一样，但是没有意义。</em></p>
<blockquote>
<p>在函数内部有个<code>arguments</code>对象(注意：是在函数内部)，<code>arguments</code>是一个伪数组对象。它表示在函数调用的过程中传入的所有参数（实参）的集合。在函数调用过程中不规定参数的个数与类型，可以使得函数调用变得非常灵活性。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>); <span class="comment">// 打印的是一个伪数组</span></span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<p><img src="http://ww1.sinaimg.cn/large/9c47d583gy1ftplepbfu5j209404ewec.jpg" alt="image"></p>
<ul>
<li><code>length</code>：表示的是实参的个数；</li>
<li><code>callee</code>：指向的就是<code>arguments</code>对象所在的函数；</li>
</ul>
<p><strong>示例代码：</strong></p>
<blockquote>
<p>封装一个求最大值的函数，因为不知道需要传进多少实参，所以直接用伪数组<code>arguments</code>获取调用的实参</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">max</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 假使实参的第一个数字最大</span></span><br><span class="line">    <span class="keyword">var</span> maxNum = <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 循环这个伪数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(maxNUm &lt; <span class="built_in">arguments</span>[i])&#123;</span><br><span class="line">            maxNUm = <span class="built_in">arguments</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxNum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="built_in">console</span>.log(max(<span class="number">1</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">8</span>,<span class="number">22</span>,<span class="number">5</span>));   <span class="comment">// 22</span></span><br></pre></td></tr></table></figure>
<h2 id="10-函数的四种调用模式"><a class="header-anchor" href="#10-函数的四种调用模式"></a>10. 函数的四种调用模式</h2>
<blockquote>
<p>四种调用模式分别是：“函数调用模式”、“方法调用模式”、“构造器调用模式”、“上下文调用模式”。</p>
</blockquote>
<p>其实就是分析<code>this</code>是谁的问题。只看函数是怎么被调用的，而不管函数是怎么来的。</p>
<ul>
<li>分析<code>this</code>属于哪个函数；</li>
<li>分析这个函数是以什么方式调用的；</li>
</ul>
<p><strong>什么是函数？ 什么是方法？</strong></p>
<blockquote>
<p>如果一个函数是挂载到一个对象中，那么就把这个函数称为方法</p>
</blockquote>
<blockquote>
<p>如果一个函数直接放在全局中，由<code>Window</code>对象调用，那么他就是一个函数。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">fn();</span><br><span class="line">f();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  say: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.say();</span><br></pre></td></tr></table></figure>
<p><em><code>fn</code>和<code>f</code>都是函数，<code>say</code>是一个方法</em></p>
<h3 id="10-1-函数模式"><a class="header-anchor" href="#10-1-函数模式"></a>10.1 函数模式</h3>
<blockquote>
<p>函数模式其实就是函数调用模式，<code>this</code>是指向全局对象<code>window</code>的。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span> -&gt; <span class="built_in">window</span></span><br></pre></td></tr></table></figure>
<p><strong>示例代码：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数调用模式：</span></span><br><span class="line"><span class="comment">// 创建的全局变量相当于window的属性</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">999</span>;</span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);  <span class="comment">// this 指向的是 window 对象</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.num); <span class="comment">// 999</span></span><br><span class="line">&#125;;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>
<h3 id="10-2-方法模式"><a class="header-anchor" href="#10-2-方法模式"></a>10.2 方法模式</h3>
<blockquote>
<p>方法模式其实就是方法调用模式，<code>this</code>是指向调用方法的对象。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span> -&gt; 调用方法的对象</span><br></pre></td></tr></table></figure>
<p><strong>示例代码：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this指向的是obj </span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">38</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  getAge: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);  <span class="comment">// this指向的是对象obj  &#123;age:18,getAge:f()&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);  <span class="comment">// 18</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br><span class="line">obj.getAge(); <span class="comment">// getAge() 是对象 obj 的一个方法</span></span><br></pre></td></tr></table></figure>
<h3 id="10-3-构造器模式"><a class="header-anchor" href="#10-3-构造器模式"></a>10.3 构造器模式</h3>
<blockquote>
<p>构造器模式其实就是构造函数调用模式，<code>this</code>指向新创建出来的实例对象。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span> -&gt; 新创建出来的实例对象</span><br></pre></td></tr></table></figure>
<p><strong>示例代码：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this指向的是实例化出来的对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'Levi'</span>); <span class="comment">// Person &#123;name: "Levi"&#125;</span></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">'Ryan'</span>); <span class="comment">// Person &#123;name: "Ryan"&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>构造函数的返回值：</strong></p>
<blockquote>
<p>如果返回的是基本类型</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(p1);  <span class="comment">// 打印Person &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p><em>构造函数内有返回值，且是基本类型的时候，返回值会被忽略掉，返回的是实例出来的对象。</em></p>
<blockquote>
<p>如果返回的是引用类型</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name: <span class="string">'levi'</span>,</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(p1); <span class="comment">// 此时打印 Object &#123;name: 'levi', age: 18&#125;</span></span><br></pre></td></tr></table></figure>
<p><em>构造函数内的返回值是一个引用类型的时候，返回的就是这个指定的引用类型。</em></p>
<h3 id="10-4-上下文-借用方法-模式"><a class="header-anchor" href="#10-4-上下文-借用方法-模式"></a>10.4 上下文（借用方法）模式</h3>
<blockquote>
<p>上下文，即环境，用于指定方法内部的<code>this</code>，上下文调用模式中，<code>this</code>可以被随意指定为任意对象。</p>
</blockquote>
<p>上下文模式有两种方法，是由函数调用的：</p>
<ul>
<li><code>函数名.apply( ... )</code>;</li>
<li><code>函数名.call( ... )</code>;</li>
</ul>
<p><strong>1、apply 方法</strong></p>
<p>语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn.apply(thisArg, array);</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一个参数：表示函数内部this的指向（或者：让哪个对象来借用这个方法）</span><br><span class="line">第二个参数：是一个数组（或者伪数组），数组中的每一项都将作为被调用方法的参数</span><br></pre></td></tr></table></figure>
<p>示例代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name : <span class="string">'Levi丶'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this 指向 obj，fn 借用obj方法里面的 name 属性</span></span><br><span class="line">fn.apply(obj);  <span class="comment">// 打印 'Levi丶'</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num1 + num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this 指向 obj，数组中的数据是方法 fn 的参数</span></span><br><span class="line">fn.apply(obj, [<span class="number">1</span> , <span class="number">2</span>]);  <span class="comment">// 打印 3</span></span><br></pre></td></tr></table></figure>
<p><em>注意：<code>apply</code>方法的第一个参数，必须是一个对象！如果传入的参数不是一个对象，那么这个方法内部会将其转化为一个包装对象。</em></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.apply(<span class="number">1</span>); <span class="comment">// 包装对象</span></span><br><span class="line">fn.apply(<span class="string">'abc'</span>); <span class="comment">// 包装对象</span></span><br><span class="line">fn.apply(<span class="literal">true</span>); <span class="comment">// 包装对象</span></span><br></pre></td></tr></table></figure>
<p><img src="http://ww1.sinaimg.cn/large/007kscFEgy1fyhverd0bsj308906ojrb.jpg" alt="image"></p>
<p>指向<code>window</code>的几种方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.apply(<span class="built_in">window</span>);</span><br><span class="line">fn.apply();</span><br><span class="line">fn.apply(<span class="literal">null</span>);</span><br><span class="line">fn.apply(<span class="literal">undefined</span>);</span><br></pre></td></tr></table></figure>
<p>具体应用：</p>
<ul>
<li>求数组中的最大数</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以前的方法，假设第一项最大，然后与后面每一项比较，得到最大的项</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">210</span>, <span class="number">23</span>, <span class="number">33</span>, <span class="number">777</span>, <span class="number">456</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> maxNum = arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span>(maxNum &lt; arr[i]) &#123;</span><br><span class="line">    maxNum = arr[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(maxNum); <span class="comment">// 777</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用 内置对象的 apply 的方法</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">210</span>, <span class="number">23</span>, <span class="number">33</span>, <span class="number">777</span>, <span class="number">456</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// max 是内置对象 Math 求最大值的一个方法</span></span><br><span class="line"><span class="keyword">var</span> maxNum = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, arr);</span><br><span class="line"><span class="built_in">console</span>.log(maxNum); <span class="comment">// 777</span></span><br></pre></td></tr></table></figure>
<ul>
<li>将传进的参数每一项之间用“<code>-</code>”连接</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 思考：参数个数是用户随机传的，没有具体的一个值，这时候就需要用到 arguments 的概念了</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 数组原型中有一个join方法，他的接收的参数是一个字符串</span></span><br><span class="line">    <span class="comment">// join.apply的第一个参数指向 arguments 对象，第二个参数是jion方法需要的参数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.join.apply(<span class="built_in">arguments</span>, [<span class="string">'-'</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ret = fn(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(ret); <span class="comment">// 'a-b-c-d-e'</span></span><br></pre></td></tr></table></figure>
<p><strong>2、call 方法</strong></p>
<blockquote>
<p><code>call</code>方法的作用于<code>apply</code>方法的作用相同，唯一不同的地方就是第二个参数不同。</p>
</blockquote>
<p>语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn.apply(thisArg, parm1,parm2,parm3,...);</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一个参数：表示函数内部this的指向（或者：让哪个对象来借用这个方法）</span><br><span class="line">第二个及后面的参数：不是之前数组的形式了，对应方法调用的每一个参数</span><br></pre></td></tr></table></figure>
<p>示例代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">num1, num2, num3</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(num1, num2, num3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">fn.call(obj, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>], <span class="number">0</span>, <span class="number">1</span>); <span class="comment">// [1, 3, 9] 0 1</span></span><br><span class="line">fn.call(obj, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>]); <span class="comment">// [1, 3, 9] undefined undefined</span></span><br></pre></td></tr></table></figure>
<p><strong>3、apply 和 call 的区别</strong></p>
<blockquote>
<p>两者在功能上一模一样，唯一的区别就是第二个参数传递的类型不一样。</p>
</blockquote>
<p>什么时候用<code>apply</code>？什么时候用<code>call</code>呢？</p>
<p>其实用哪个都可以，在参数少的情况下，我们可以使用<code>call</code>方法，但是如果参数是伪数组或者是数组的时候，<code>call</code>方法就不适用了，还需要将伪数组中的每一项取出来作为方法的参数，此时<code>apply</code>更加实用。</p>
<h3 id="10-5-面试题分析"><a class="header-anchor" href="#10-5-面试题分析"></a>10.5 面试题分析</h3>
<p><strong>面试题1：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">38</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    getAge: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.age); <span class="comment">// 这里的this属于函数 foo；   打印 38</span></span><br><span class="line">        &#125;</span><br><span class="line">        foo(); <span class="comment">// foo函是Window对象调用的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.getAge();</span><br></pre></td></tr></table></figure>
<p><strong>面试题2：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只看函数是怎么被调用的，而不管函数是怎么来的</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">38</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    getAge: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.age); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = obj.getAge;</span><br><span class="line">f(); <span class="comment">// 函数是Window对象调用的，所以this指向Window对象。打印：38</span></span><br></pre></td></tr></table></figure>
<p><strong>面试题3：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> length = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    length: <span class="number">5</span>,</span><br><span class="line">    method: <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">        fn();   <span class="comment">// window对象调用 打印 10</span></span><br><span class="line">        <span class="built_in">arguments</span>[<span class="number">0</span>](); <span class="comment">// 方法调用模式，是arguments对象调用的  </span></span><br><span class="line">        <span class="comment">// this指向arguments，所以arguments.length = 2; （arguments.length：实参的个数）所以打印 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.method(fn, <span class="number">123</span>);</span><br></pre></td></tr></table></figure>
<p><strong>面试题4：</strong></p>
<blockquote>
<p>怎么使用<code>call</code>或者<code>apply</code>方法实现构造函数的复用呢？</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, gender</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.gender = gender;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Teacher</span>(<span class="params">name, age, gender, workYear, subject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.gender = gender;</span><br><span class="line">  <span class="keyword">this</span>.workYear = workYear;</span><br><span class="line">  <span class="keyword">this</span>.subject = subject;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, gender, stuNo, score</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.gender = gender;</span><br><span class="line">  <span class="keyword">this</span>.stuNo = stuNo;</span><br><span class="line">  <span class="keyword">this</span>.score = score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tec = <span class="keyword">new</span> Teacher(<span class="string">'张老师'</span>, <span class="number">32</span>, <span class="string">'male'</span>, <span class="string">'7年'</span>, <span class="string">'语文'</span>);</span><br><span class="line"><span class="keyword">var</span> stu = <span class="keyword">new</span> Student(<span class="string">'xiaowang'</span>, <span class="number">18</span>, <span class="string">'male'</span>, <span class="number">10001</span>, <span class="number">99</span>);</span><br><span class="line"><span class="built_in">console</span>.log(tec); <span class="comment">// Teacher &#123;name: "张老师", age: 32, gender: "male", workYear: "7年", subject: "语文"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(stu); <span class="comment">// Student &#123;name: "xiaowang", age: 18, gender: "male", stuNo: 10001, score: 99&#125;</span></span><br></pre></td></tr></table></figure>
<p><em>上面的代码中一个<code>Teacher</code>构造函数，一个<code>Student</code>构造函数，他们都有一些公共的属性，跟<code>Perso</code>n构造函数里面的属性重复，我们能否使用<code>call</code>或者<code>apply</code>方法，简化上面的代码呢？</em></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, gender</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.gender = gender;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Teacher</span>(<span class="params">name, age, gender, workYear, subject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 借用 Person 函数来给当前对象添加属性</span></span><br><span class="line">  Person.call(<span class="keyword">this</span>, name, age, gender);  <span class="comment">// 这里的this指向的就是当前的Teacher构造函数</span></span><br><span class="line">  <span class="keyword">this</span>.workYear = workYear;</span><br><span class="line">  <span class="keyword">this</span>.subject = subject;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, gender, stuNo, score</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="keyword">this</span>, name, age, gender);  <span class="comment">// 这里的this指向的就是当前的Student构造函数</span></span><br><span class="line">  <span class="keyword">this</span>.stuNo = stuNo;</span><br><span class="line">  <span class="keyword">this</span>.score = score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tec = <span class="keyword">new</span> Teacher(<span class="string">'张老师'</span>, <span class="number">32</span>, <span class="string">'male'</span>, <span class="string">'7年'</span>, <span class="string">'语文'</span>);</span><br><span class="line"><span class="keyword">var</span> stu = <span class="keyword">new</span> Student(<span class="string">'xiaowang'</span>, <span class="number">18</span>, <span class="string">'male'</span>, <span class="number">10001</span>, <span class="number">99</span>);</span><br><span class="line"><span class="built_in">console</span>.log(tec); <span class="comment">// Teacher &#123;name: "张老师", age: 32, gender: "male", workYear: "7年", subject: "语文"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(stu); <span class="comment">// Student &#123;name: "xiaowang", age: 18, gender: "male", stuNo: 10001, score: 99&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="11-递归"><a class="header-anchor" href="#11-递归"></a>11.递归</h2>
<h3 id="11-1-什么是递归"><a class="header-anchor" href="#11-1-什么是递归"></a>11.1 什么是递归</h3>
<blockquote>
<p>什么是递归？递归就是函数直接自己调用自己或者间接的调用自己。</p>
</blockquote>
<p><strong>举个例子：</strong></p>
<ul>
<li>函数直接调用自己</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    fn();</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>
<ul>
<li>函数间接调用自己</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    fn2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    fn1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>递归示例代码：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'从前有座山，'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'山里有座庙，'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'庙里有个老和尚，'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'老和尚给小和尚讲，'</span>);</span><br><span class="line">    fn();</span><br><span class="line">&#125;</span><br><span class="line">fn();  <span class="comment">// 产生递归，无限打印上面的内容</span></span><br></pre></td></tr></table></figure>
<p><em>这样做会进入到无限的死循环当中。</em></p>
<h3 id="11-2-化归思想"><a class="header-anchor" href="#11-2-化归思想"></a>11.2 化归思想</h3>
<blockquote>
<p>化归思想是将一个问题由难化易，由繁化简，由复杂化简单的过程称为化归，它是转化和归结的简称。</p>
</blockquote>
<p><strong>合理使用递归的注意点：</strong></p>
<ul>
<li>函数调用了自身</li>
<li>必须有结束递归的条件，这样程序就不会一直运行下去了</li>
</ul>
<p><strong>示例代码：</strong> 求前<code>n</code>项的和</p>
<ul>
<li>求前<code>n</code>项的和其实就是：<code>1 + 2 + 3 +...+ n</code>；</li>
<li>寻找递推关系，就是<code>n</code>与<code>n-1</code>, 或<code>n-2</code>之间的关系:<code>sum(n) == n + sum(n - 1)</code>；</li>
<li>加上结束的递归条件，不然会一直运行下去。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// 递归结束条件 </span></span><br><span class="line">    <span class="keyword">return</span> n + sum(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="number">100</span>); <span class="comment">// 打印 5050</span></span><br></pre></td></tr></table></figure>
<p><strong>递推关系：</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/9c47d583gy1fudubcaosgj20pc0iyk6t.jpg" alt="image"></p>
<h3 id="11-3-递归练习"><a class="header-anchor" href="#11-3-递归练习"></a>11.3 递归练习</h3>
<p><strong>1、求n的阶乘：</strong></p>
<p>思路：</p>
<ul>
<li><code>f(n) = n * f(n - 1);</code></li>
<li><code>f(n - 1) = (n - 1) * f(n - 2);</code></li>
</ul>
<p>示例代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">product</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n * product(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(product(<span class="number">5</span>));  <span class="comment">// 打印 120</span></span><br></pre></td></tr></table></figure>
<p><strong>2、求m的n次幂：</strong></p>
<p>思路：</p>
<ul>
<li><code>f(m,n) = m * f(m,n-1);</code></li>
</ul>
<p>示例代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pow</span>(<span class="params">m,n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m * pow(m,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(pow(<span class="number">2</span>, <span class="number">10</span>));  <span class="comment">// 打印 1024</span></span><br></pre></td></tr></table></figure>
<p><strong>3、斐波那契数列</strong></p>
<p>思路：什么是斐波那契数列？</p>
<p><code>1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 , 55,...</code></p>
<blockquote>
<p>数字从第三项开始，每一项都等于前两项的和。可得出公式：<code>fn = f(n-1) + f(n-2)</code>，结束递归的条件：当<code>n &lt;= 2</code>时，<code>fn = 1</code>。</p>
</blockquote>
<p>示例代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// 结束递归的条件</span></span><br><span class="line">    <span class="keyword">return</span> fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fib(<span class="number">5</span>)); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(fib(<span class="number">10</span>)); <span class="comment">// 55</span></span><br><span class="line"><span class="built_in">console</span>.log(fib(<span class="number">25</span>)); <span class="comment">// 75025   // 数值太大会影响性能问题</span></span><br></pre></td></tr></table></figure>
<p>存在问题：</p>
<blockquote>
<p>数值太大时会影响性能，怎么影响的呢？</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>);</span><br><span class="line">    <span class="comment">// 当我们在计算一个值的时候，都是通过计算他的fib(n-1) 跟 fib(n-2)项之后再去进行相加，得到最终的值</span></span><br><span class="line">    <span class="comment">// 这时候就需要调用两次这个函数，在计算fib(n-1)的时候，其实也是调用了两次这个函数，得出fib(n-1)的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录执行的次数</span></span><br><span class="line"><span class="keyword">var</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">fib</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> fib(n<span class="number">-1</span>)+fib(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fib(<span class="number">5</span>));  <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(count);   <span class="comment">// 9  求第五项的时候就计算了9次</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//console.log(fib(20));  // 6765</span></span><br><span class="line"><span class="comment">//console.log(count);   // 13529  求第20项的时候就计算了13529次</span></span><br></pre></td></tr></table></figure>
<p><img src="http://ww1.sinaimg.cn/large/9c47d583gy1fujdj20wq1j20qu0kzdyo.jpg" alt="image"></p>
<p><em>这个问题在下面讲闭包的时候解决。</em></p>
<p><strong>4.获取页面所有的元素，并加上边框</strong></p>
<p>页面结构：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>我是span标签<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>我是span标签<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>我是span标签<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>我是span标签<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>我是span标签<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>我是span标签<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>我是span标签<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>我是span标签<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>我是span标签<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>我是span标签<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>我是span标签<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>我是span标签<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>结构图：</p>
<p><img src="http://ww1.sinaimg.cn/large/9c47d583gy1fujef7wiy9j20vi0gg4b0.jpg" alt="image"></p>
<p>js代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装一个方法，获取到所有的标签，并且给这些标签加上边框</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">childrenTag</span>(<span class="params">ele</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> eleArr = []; <span class="comment">// 用于存放所有的获取到的标签</span></span><br><span class="line">    <span class="keyword">var</span> elements = ele.children; <span class="comment">// 获取传入元素下的直接子元素 （伪数组）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; elements.length; i++)&#123;</span><br><span class="line">        eleArr.push(elements[i]);</span><br><span class="line">        <span class="comment">// 获取子元素下的直接子元素</span></span><br><span class="line">        <span class="keyword">var</span> temp = childrenTag(elements[i]);  <span class="comment">// 一层层的递推下去</span></span><br><span class="line">        eleArr = eleArr.concat(temp); <span class="comment">// 将获取的子元素的拼接到一起</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> eleArr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(childrenTag(<span class="built_in">document</span>.body)); <span class="comment">// 打印的就是页面body下所有的标签</span></span><br><span class="line"><span class="comment">// 获取所有标签</span></span><br><span class="line"><span class="keyword">var</span> tags=childrenTag(<span class="built_in">document</span>.body);</span><br><span class="line"><span class="comment">// 给所有标签添加边框</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;tags.length;i++)&#123;</span><br><span class="line">    tags[i].style.border=<span class="string">'1px solid cyan'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果图：</p>
<p><img src="http://ww1.sinaimg.cn/large/9c47d583gy1fujh6gh7acj20j00870ss.jpg" alt="image"></p>
<h2 id="12-js-内存管理"><a class="header-anchor" href="#12-js-内存管理"></a>12. JS 内存管理</h2>
<blockquote>
<p>本章引用自：<a href="https://note.youdao.com/" target="_blank" rel="noopener">《MDN-内存管理》</a></p>
</blockquote>
<h3 id="12-1-内存生命周期"><a class="header-anchor" href="#12-1-内存生命周期"></a>12.1 内存生命周期</h3>
<blockquote>
<p>不管是什么程序语言，内存生命周期基本是一致的：</p>
</blockquote>
<ul>
<li>分配你所需要的内存；</li>
<li>使用分配到的内存（读、写）；</li>
<li>不需要时将其释放、归还。</li>
</ul>
<p><strong>JavaScript 的内存分配：</strong></p>
<blockquote>
<p>为了不让程序员费心分配内存，<code>JavaScript</code>在定义变量时就完成了内存分配。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">123</span>;        <span class="comment">// 给数值变量分配内存</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">"Levi"</span>;     <span class="comment">// 给字符串分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="literal">null</span></span><br><span class="line">&#125;;      <span class="comment">// 给对象及其包含的值分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给数组及其包含的值分配内存（就像对象一样）</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="literal">null</span>, <span class="string">"abra"</span>]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + <span class="number">2</span>;</span><br><span class="line">&#125;   <span class="comment">// 给函数（可调用的对象）分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式也能分配一个对象</span></span><br><span class="line">someElement.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  someElement.style.backgroundColor = <span class="string">'blue'</span>;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p><strong>使用值：</strong></p>
<blockquote>
<p>使用值的过程实际上是对分配内存进行读取与写入的操作。读取与写入可能是写入一个变量或者一个对象的属性值，甚至传递函数的参数。</p>
</blockquote>
<p><strong>当内存不再需要使用时释放：</strong></p>
<blockquote>
<p>大多数内存管理的问题都在这个阶段。在这里最艰难的任务是找到“所分配的内存确实已经不再需要了”。它往往要求开发人员来确定在程序中哪一块内存不再需要并且释放它。</p>
</blockquote>
<p><em>高级语言解释器嵌入了“垃圾回收器”，它的主要工作是跟踪内存的分配和使用，以便当分配的内存不再使用时，自动释放它。这只能是一个近似的过程，因为要知道是否仍然需要某块内存是无法判定的（无法通过某种算法解决）。</em></p>
<h3 id="12-2-垃圾回收"><a class="header-anchor" href="#12-2-垃圾回收"></a>12.2 垃圾回收</h3>
<blockquote>
<p>如上所述，自动寻找是否一些内存“不再需要”的问题是无法判定的。因此，垃圾回收实现只能有限制的解决一般问题。本节将解释必要的概念，了解主要的垃圾回收算法和它们的局限性。</p>
</blockquote>
<p><strong>1、引用：</strong></p>
<blockquote>
<p>垃圾回收算法主要依赖于引用的概念。在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。例如，一个<code>Javascript</code>对象具有对它原型的引用（隐式引用）和对它属性的引用（显式引用）。</p>
</blockquote>
<p><em>在这里，“对象”的概念不仅特指<code>JavaScript</code>对象，还包括函数作用域（或者全局词法作用域）。</em></p>
<p><strong>2、引用计数垃圾收集：</strong></p>
<blockquote>
<p>这是最天真的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。</p>
</blockquote>
<ul>
<li><strong>示例代码</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; </span><br><span class="line">  a: &#123;</span><br><span class="line">    b:<span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o</span></span><br><span class="line"><span class="comment">// 很显然，没有一个可以被垃圾收集</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o2 = o; <span class="comment">// o2变量是第二个对“这个对象”的引用</span></span><br><span class="line"></span><br><span class="line">o = <span class="number">1</span>;      <span class="comment">// 现在，“这个对象”的原始引用o被o2替换了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oa = o2.a; <span class="comment">// 引用“这个对象”的a属性</span></span><br><span class="line"><span class="comment">// 现在，“这个对象”有两个引用了，一个是o2，一个是oa</span></span><br><span class="line"></span><br><span class="line">o2 = <span class="string">"yo"</span>; <span class="comment">// 最初的对象现在已经是零引用了</span></span><br><span class="line">           <span class="comment">// 他可以被垃圾回收了</span></span><br><span class="line">           <span class="comment">// 然而它的属性a的对象还在被oa引用，所以还不能回收</span></span><br><span class="line"></span><br><span class="line">oa = <span class="literal">null</span>; <span class="comment">// a属性的那个对象现在也是零引用了</span></span><br><span class="line">           <span class="comment">// 它可以被垃圾回收了</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>限制：循环引用</strong></li>
</ul>
<blockquote>
<p>该算法有个限制：无法处理循环引用。在下面的例子中，两个对象被创建，并互相引用，形成了一个循环。它们被调用之后会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> o2 = &#123;&#125;;</span><br><span class="line">  o.a = o2; <span class="comment">// o 引用 o2</span></span><br><span class="line">  o2.a = o; <span class="comment">// o2 引用 o</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">"azerty"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f();</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>实际例子：</strong></li>
</ul>
<blockquote>
<p><code>IE 6, 7</code>使用引用计数方式对<code>DOM</code>对象进行垃圾回收。该方式常常造成对象被循环引用时<code>内存发生泄漏</code>：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div;</span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  div = <span class="built_in">document</span>.getElementById(<span class="string">"myDivElement"</span>);</span><br><span class="line">  div.circularReference = div;</span><br><span class="line">  div.lotsOfData = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10000</span>).join(<span class="string">"*"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><em>在上面的例子里，<code>myDivElement</code>这个<code>DOM</code>元素里的<code>circularReference</code>属性引用了<code>myDivElement</code>，造成了循环引用。如果该属性没有显示移除或者设为<code>null</code>，引用计数式垃圾收集器将总是且至少有一个引用，并将一直保持在内存里的<code>DOM</code>元素，即使其从<code>DOM</code>树中删去了。如果这个<code>DOM</code>元素拥有大量的数据(如上的<code>lotsOfData</code>属性)，而这个数据占用的内存将永远不会被释放。</em></p>
<p><strong>3、标记-清除算法</strong></p>
<blockquote>
<p>这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。</p>
</blockquote>
<p>这个算法假定设置一个叫做根（<code>root</code>）的对象（在<code>Javascript</code>里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。</p>
<p>这个算法比前一个要好，因为“有零引用的对象”总是不可获得的，但是相反却不一定，参考“循环引用”。</p>
<p>从<code>2012</code>年起，所有现代浏览器都使用了<code>标记-清除垃圾</code>回收算法。所有对<code>JavaScript</code>垃圾回收算法的改进都是基于标记-清除算法的改进，并没有改进标记-清除算法本身和它对“对象是否不再需要”的简化定义。</p>
<ul>
<li><strong>循环引用不再是问题了</strong></li>
</ul>
<blockquote>
<p>在上面的示例中，函数调用返回之后，两个对象从全局对象出发无法获取。因此，他们将会被垃圾回收器回收。第二个示例同样，一旦<code>div</code>和其事件处理无法从根获取到，他们将会被垃圾回收器回收。</p>
</blockquote>
<ul>
<li><strong>限制: 那些无法从根对象查询到的对象都将被清除</strong></li>
</ul>
<blockquote>
<p>尽管这是一个限制，但实践中我们很少会碰到类似的情况，所以开发者不太会去关心垃圾回收机制。</p>
</blockquote>
<p><em>一般情况下, 如果需要手动释放变量占用的内存, 就将这个变量赋值为:<code>null</code></em></p>
<h2 id="13-闭包"><a class="header-anchor" href="#13-闭包"></a>13. 闭包</h2>
<blockquote>
<p>了解闭包之前，先了解下另外两个知识点：</p>
</blockquote>
<p><strong>1、函数基础知识</strong></p>
<ul>
<li>1、函数内部的代码在调用的时候执行</li>
<li>2、函数返回值类型可以是任意类型</li>
<li>3、怎么理解函数的返回值
<ul>
<li>将函数内部声明的变量暴露到函数外部</li>
<li>函数内用来返回数据，相当于没有函数的时候直接使用该数据</li>
<li>不同之处在于：函数形成作用域，变量为局部变量</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = &#123;<span class="attr">age</span>: <span class="number">12</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o1 = foo();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于： var o1 = &#123;age: 18&#125;;</span></span><br></pre></td></tr></table></figure>
<p><strong>2、作用域的结论</strong></p>
<ul>
<li>1、<code>JavaScript</code>的作用域是词法作用域</li>
<li>2、函数才会形成作用域(函数作用域)</li>
<li>3、词法作用域：变量(变量和函数)的作用范围在代码写出来的就已经决定, 与运行时无关</li>
<li>4、函数内部可以访问函数外部的变量（函数外部不能访问函数内部的变量）</li>
<li>5、变量搜索原则：从当前链开始查找直到<code>0</code>级链</li>
<li>6、当定义了一个函数，当前的作用域链就保存起来，并且成为函数的内部状态的一部分。</li>
</ul>
<h3 id="13-1-闭包的概念"><a class="header-anchor" href="#13-1-闭包的概念"></a>13.1 闭包的概念</h3>
<blockquote>
<p>闭包从字面意思理解就是闭合，包起来。简单的来说闭包就是，一个具有封闭的对外不公开的包裹结构或空间。</p>
</blockquote>
<p>在<code>JavaScript</code>中函数可以构成闭包。一般函数是一个代码结构的封闭结构，即包裹的特性。同时根据作用域规则， 只允许函数访问外部的数据，外部无法访问函数内部的数据，即封闭的对外不公开的特性。因此说函数可以构成闭包。</p>
<p><strong>闭包的其他解释</strong></p>
<blockquote>
<p>在计算机科学中，闭包（英语：<code>Closure</code>），又称词法闭包（<code>Lexical Closure</code>）或函数闭包（<code>function closures</code>），是引用了自由变量的函数。</p>
</blockquote>
<ul>
<li>这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。</li>
<li>闭包在运行时可以有多个<code>实例</code>，不同的引用环境和相同的函数组合可以产生不同的<code>实例</code>。</li>
</ul>
<p><code>实例：</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(num);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bar1就是闭包的一个实例</span></span><br><span class="line"><span class="keyword">var</span> bar1 = fn();</span><br><span class="line"><span class="comment">// bar2就是闭包的另外一个实例</span></span><br><span class="line"><span class="keyword">var</span> bar2 = fn();</span><br><span class="line"></span><br><span class="line">bar1(); <span class="comment">// 123</span></span><br><span class="line">bar2(); <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>
<p><strong>闭包的构成</strong></p>
<blockquote>
<p>闭包包括两部分：</p>
</blockquote>
<ul>
<li>1、函数体（函数自身的代码）；</li>
<li>2、环境（函数的作用域）。</li>
</ul>
<p><strong>闭包的说明</strong></p>
<ul>
<li>1、<code>JS</code>中函数形成了闭包</li>
<li>2、闭包是函数作用域的应用</li>
<li>3、对于闭包来说，只关注<code>创建函数的作用域</code>，不关注调用函数的位置</li>
</ul>
<p><strong>闭包的作用</strong></p>
<ul>
<li>对函数内部的变量起到保护作用</li>
<li>除了返回的函数以外，没有任何手段能够获取或者修改这个变量的值</li>
</ul>
<h3 id="13-2-闭包模型"><a class="header-anchor" href="#13-2-闭包模型"></a>13.2 闭包模型</h3>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 函数会产生一个作用域，所以外部的程序想要访问函数内部的变量，一般情况下是不行的</span></span><br><span class="line">    <span class="comment">// 通过闭包的方式可以使外部访问到函数内部的变量</span></span><br><span class="line">    <span class="comment">// 具体做法就是在函数内部返回一个函数，并且这个函数使用了这个变量</span></span><br><span class="line">    <span class="comment">// 当用户调用最外层的函数的时候，使用的这个变量就会随着返回的函数返回给用户</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ++num;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数foo的返回值就是一个函数，所以，就可以调用getNum这个函数了！</span></span><br><span class="line"><span class="keyword">var</span> getNum = foo();</span><br><span class="line"><span class="built_in">console</span>.log(getNum());   <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h3 id="13-3-闭包的使用"><a class="header-anchor" href="#13-3-闭包的使用"></a>13.3 闭包的使用</h3>
<blockquote>
<p>目标：想办法（在外部）访问到函数内部的数据</p>
</blockquote>
<p><strong>利用函数返回值</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="built_in">Math</span>.random();</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num1 = foo();</span><br><span class="line"><span class="keyword">var</span> num2 = foo();</span><br><span class="line"><span class="built_in">console</span>.log(num1 === num2);  <span class="comment">// 随机数 相同的情况很小很小</span></span><br></pre></td></tr></table></figure>
<p><strong>普通的函数返回值说明</strong></p>
<ul>
<li>两次调用函数，返回的数据并不是同一个数据。</li>
<li>原因：函数在每次调用的时候，内部的数据会被新创建一次</li>
</ul>
<p><strong>游戏充值案例</strong></p>
<ul>
<li><strong>示例图片：</strong></li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/9c47d583gy1fuoiq03p4lg20ed0dmaeb.gif" alt="image"></p>
<ul>
<li><strong>示例代码：</strong></li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"pay"</span>&gt;</span>充值<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"play"</span>&gt;</span>玩游戏<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 需求：</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 1-需要对充值的金额起到保护作用，这个存放数值的变量不能暴露在全局，否则谁都会去修改这个金额</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//   var money = 0;</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 2-点击充值按钮的时候，每次充值10元</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 3-点击玩游戏按钮的时候，每玩一次金额减少一元</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> money = <span class="number">0</span>; <span class="comment">// money用来存储充值的钱，放在函数内部，不会暴露在全局</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 一般的闭包返回值是一个函数，但是这里有两个功能，一个是玩游戏，一个是充值；</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 两个功能分开，但是金额之间还是关联的，所以这里返回一个对象，里面存放两个方法</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 充值的函数</span></span></span><br><span class="line"><span class="javascript">            recharge:<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span></span><br><span class="line"><span class="undefined">                money += value;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">'尊敬的黄金会员，您本次充值：'</span> + value, <span class="string">'，您的总余额为：'</span> + money);</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 玩游戏的函数</span></span></span><br><span class="line"><span class="javascript">            play:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span>(money &lt;= <span class="number">0</span>)&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(<span class="string">'余额不足无法继续游戏，请充值！'</span>);</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">return</span>;</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">                money--;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">'您还剩余 '</span> + money + <span class="string">' 条命！'</span>);</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> obj = fn();</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 点击“充值”按钮</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> pay = <span class="built_in">document</span>.getElementById(<span class="string">'pay'</span>);</span></span><br><span class="line"><span class="javascript">    pay.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">        obj.recharge(10);</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 点击“玩游戏”按钮</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> play = <span class="built_in">document</span>.getElementById(<span class="string">'play'</span>)</span></span><br><span class="line"><span class="javascript">    play.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">        obj.play();</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>优化，多个角色进行充值玩游戏</strong></li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"pay"</span>&gt;</span>小明：充值<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"play"</span>&gt;</span>小明：玩游戏<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"pay1"</span>&gt;</span>小华：充值<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"play1"</span>&gt;</span>小华：玩游戏<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 1 需要对充值的钱起到保护作用</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// var money = 0;</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 2 充值：    每次充值20</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 3 玩游戏：  每玩一次，金额少1</span></span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="javascript">    <span class="comment">// 整个fn()形成一个函数作用域，对里面的变量起到保护作用</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// money 用来存储充值的钱</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> money = <span class="number">0</span>;</span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="javascript">      <span class="comment">// 充值的函数：</span></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">recharge</span>(<span class="params">value</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// money += 20;</span></span></span><br><span class="line"><span class="undefined">        money += value;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'尊敬的黄金会员，您本次充值：'</span> + value, <span class="string">'，您的总余额为：'</span> + money);</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="javascript">      <span class="comment">// 玩游戏的函数</span></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">play</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">        money--;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (money &lt; <span class="number">0</span>) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'余额不足，请充值！'</span>);</span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'您还剩余 '</span> + money + <span class="string">' 条命！'</span>);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="undefined">        recharge: recharge,</span></span><br><span class="line"><span class="undefined">        play: play</span></span><br><span class="line"><span class="undefined">      &#125;;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="javascript">    <span class="comment">// 小明充值玩游戏的函数</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> obj;</span></span><br><span class="line"><span class="undefined">    obj = fn();</span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="javascript">    <span class="comment">// 小明玩游戏：</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> pay = <span class="built_in">document</span>.getElementById(<span class="string">'pay'</span>);</span></span><br><span class="line"><span class="javascript">    pay.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">      obj.recharge(20);</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> play = <span class="built_in">document</span>.getElementById(<span class="string">'play'</span>)</span></span><br><span class="line"><span class="javascript">    play.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">      obj.play();</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="javascript">    <span class="comment">// 小华（新的闭包实例）：</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> obj1 = fn();</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 小华玩游戏：</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> pay1 = <span class="built_in">document</span>.getElementById(<span class="string">'pay1'</span>);</span></span><br><span class="line"><span class="javascript">    pay1.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">      obj1.recharge(20);</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> play1 = <span class="built_in">document</span>.getElementById(<span class="string">'play1'</span>)</span></span><br><span class="line"><span class="javascript">    play1.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">      obj1.play();</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><em>优化的案例我们可以看到，只要重新定义一个变量，接收函数<code>fn()</code>，就能重新开辟一个新的空间，且多个用户之间不受任何影响。</em></p>
<h3 id="13-4-闭包里的缓存"><a class="header-anchor" href="#13-4-闭包里的缓存"></a>13.4 闭包里的缓存</h3>
<p><strong>从内存看闭包</strong></p>
<blockquote>
<p>函数调用也是需要内存的！因为函数中声明了一些变量，这些变量在函数调用过程中是可以使用的，所以, 这个变量是存储到了函数调用时候分配的内存中了！因为没有任何变量来引用这块内存，所以，函数调用结束。 函数调用占用的内存就会被回收掉。</p>
</blockquote>
<p>虽然，此时的函数有返回值(返回了一个普通的变量)，并且这个函数调用结束以后这个函数占用的内存还是被回收了！但是, 存储函数的内存还在。</p>
<p><strong>闭包的内存占用:</strong></p>
<blockquote>
<p>作用域的引用是对函数整个作用域来说的，而不是针对作用域中的某个变量！！！即便没有任何的变量，也是有作用域( 作用域的引用 )。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(num);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此时, 函数fn调用时候占用的内存, 是不会被释放掉的!!!</span></span><br><span class="line"><span class="keyword">var</span> foo = fn();</span><br><span class="line"><span class="comment">// 调用 foo() 此时, 因为返回函数的作用域对外层函数fn的作用域有引用</span></span><br><span class="line"><span class="comment">// 所以, 即使是 fn() 调用结束了, 因为 返回函数作用域引用的关系, 所以</span></span><br><span class="line"><span class="comment">// 函数fn()调用时候, 产生的内存是不会被释放掉的!</span></span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动释放闭包占用的内存!</span></span><br><span class="line">foo = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p><strong>缓存介绍</strong></p>
<ul>
<li>缓存：暂存数据方便后续计算中使用。</li>
<li>缓存中存储的数据简单来说就是：键值对</li>
<li>工作中，缓存是经常被使用的手段。</li>
<li>目的：提高程序运行的效率</li>
<li>我们只要是使用缓存，就完全信赖缓存中的数据。所以， 我们可以通过闭包来保护缓存。</li>
</ul>
<p><em>对于缓存来说，我们既要存储值，又要取值！存储的目的是为了将来取出来，在<code>js</code>中可以使用对象或者数组来充当缓存。</em></p>
<p>如果是需要保持顺序的，那么就用数组，否则就用对象！</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个缓存：</span></span><br><span class="line"><span class="keyword">var</span> cache = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 往缓存中存数据：</span></span><br><span class="line">cache.name = <span class="string">'xiaoming'</span>;</span><br><span class="line">cache[<span class="string">'name1'</span>] = <span class="string">'xiaohua'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取值</span></span><br><span class="line"><span class="built_in">console</span>.log(cache.name);</span><br><span class="line"><span class="built_in">console</span>.log(cache[<span class="string">'name1'</span>]);</span><br></pre></td></tr></table></figure>
<p><em>计算机中的缓存就是数据交换的缓冲区（称作<code>Cache</code>），当某一硬件要读取数据时，会首先从缓存中查找需要的数据，如果找到了则直接执行，找不到的话则从内存中找。由于缓存的运行速度比内存快得多，故缓存的作用就是帮助硬件更快地运行。</em></p>
<p><strong>缓存使用步骤</strong></p>
<ul>
<li>首先查看缓存中有没有该数据，</li>
<li>如果有，直接从缓存中取出来；</li>
<li>如果没有就递归计算，并将结果放到缓存中</li>
</ul>
<p><strong>递归计算斐波那契数列存在的问题</strong></p>
<blockquote>
<p>前面在学习递归的时候，我们举了一个斐波那契数列的例子，但是当时说存在性能问题，我们重新看下这个问题。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用递归计算 菲波那契数列</span></span><br><span class="line"><span class="comment">// 数列：1 1 2 3 5 8 13 21 34 55 89 。。。</span></span><br><span class="line"><span class="comment">// 索引：0 1 2 3 4 5 6  7  8  9  10 。。。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> fib = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">  count++;</span><br><span class="line">  <span class="keyword">if</span> (num === <span class="number">0</span> || num == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fib(num - <span class="number">1</span>) + fib(num - <span class="number">2</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算索引号为10的值, 一共计算了:  177 次</span></span><br><span class="line"><span class="comment">// 计算索引号为11的值, 一共计算了:  287 次</span></span><br><span class="line"><span class="comment">// 计算索引号为12的值, 一共计算了:  465 次</span></span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line"><span class="comment">// 计算索引号为20的值, 一共计算了:  21891 次</span></span><br><span class="line"><span class="comment">// 计算索引号为21的值, 一共计算了:  35421 次</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 计算索引号为30的值, 一共计算了:  2692537 次</span></span><br><span class="line"><span class="comment">// 计算索引号为31的值, 一共计算了:  4356617 次</span></span><br><span class="line"></span><br><span class="line">fib(<span class="number">31</span>);</span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 4356617</span></span><br></pre></td></tr></table></figure>
<p><em>注意上面代码，<code>count</code>是用来记录程序运行时执行的次数，不明白的小伙伴可以返回递归那一章节，我专门画了一张图，可以理解下这个次数是怎么计算的。我们看下上面的代码的注释，求第<code>20</code>项跟<code>21</code>项的时候，虽然只相差一项，但是却多运算了一万多次，试想一下这里面存在的效率问题是多么的可怕。</em></p>
<p><strong>闭包和缓存解决计算斐波那契数列存在的问题</strong></p>
<blockquote>
<p>其实主要的问题就是，数据重复运算。比如计算第五项的时候，他计算的是第三项跟第四项的和，这时的第三项跟第四项都是从一开始重新计算的，假如吧计算过得值保存下来，就不需要再重复的运算。</p>
</blockquote>
<ul>
<li>运用缓存：将计算的值存储下来，减少运算次数，提高效率；</li>
<li>使用闭包：从来保护缓存。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录计算的次数</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 缓存对象</span></span><br><span class="line">  <span class="keyword">var</span> cache = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个返回函数才是 递归函数!</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"> num </span>) </span>&#123;</span><br><span class="line">    count++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 首先查看缓存中有没有 num 对应的数据</span></span><br><span class="line">    <span class="keyword">if</span>(cache[num]) &#123;</span><br><span class="line">      <span class="comment">// 说明缓存中有我们需要的数据</span></span><br><span class="line">      <span class="keyword">return</span> cache[num];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 如果缓存中没有, 就先计算, 并且将计算的结果存储到缓存中</span></span><br><span class="line">    <span class="keyword">if</span>(num === <span class="number">0</span> || num === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// 存储到缓存中</span></span><br><span class="line">      cache[num] = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> temp = <span class="built_in">arguments</span>.callee(num - <span class="number">1</span>) + <span class="built_in">arguments</span>.callee(num - <span class="number">2</span>);</span><br><span class="line">    cache[num] = temp;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fib = fn();</span><br><span class="line"><span class="keyword">var</span> ret = fib(<span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.log(ret);   <span class="comment">// 10946</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'计算了:'</span> , count, <span class="string">'次'</span>);  <span class="comment">// 计算了: 39 次</span></span><br></pre></td></tr></table></figure>
<p><em>我们可以跟上面没有使用缓存，求斐波那契数列的比较一下，此时求第<code>20</code>项的时候，仅仅运算了<code>39</code>次，但是在之前却运行了<code>21891</code>次。</em></p>
<p>上面的方法存在着一些的问题，每次在执行的时候，函数<code>fn</code>都要先被调用一次（<code>var fib = fn();</code>），下面进行优化：</p>
<ul>
<li>将<code>fn</code>转换成自执行函数（沙箱模式，下一章会讲），自执行函数的返回函数就是递归函数；</li>
<li>判断缓存是否存在的条件进行优化，之前是通过判断缓存的值是否存在，来进行存、取值的，但是假如一个缓存的值是<code>false</code>的时候呢？岂不是<code>if(false){}</code>了，明明有值的时候，却不能取值了，所以玩我们只需要判断缓存里是否存在某个键就行。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fib = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 缓存对象</span></span><br><span class="line">  <span class="keyword">var</span> cache = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个返回函数才是 递归函数!</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1 首先查看缓存中有没有 num 对应的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        if(cache[num]) &#123;</span></span><br><span class="line"><span class="comment">          return cache[num];</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 只要缓存对象中存在 num 这个key, 那么结果就应该是 true</span></span><br><span class="line">    <span class="keyword">if</span> (num <span class="keyword">in</span> cache) &#123;</span><br><span class="line">      <span class="comment">// 说明缓存中有我们需要的数据</span></span><br><span class="line">      <span class="keyword">return</span> cache[num];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 如果缓存中没有, 就先计算, 并且将计算的结果存储到缓存中</span></span><br><span class="line">    <span class="keyword">if</span> (num === <span class="number">0</span> || num === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// 存储到缓存中</span></span><br><span class="line">      <span class="comment">// cache[num] = 1 是一个赋值表达式, 赋值表达式的结果为: 等号右边的值!</span></span><br><span class="line">      <span class="keyword">return</span> (cache[num] = <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// arguments.callee 表示当前函数的引用</span></span><br><span class="line">    <span class="keyword">return</span> (cache[num] = <span class="built_in">arguments</span>.callee(num - <span class="number">1</span>) + <span class="built_in">arguments</span>.callee(num - <span class="number">2</span>));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ret = fib(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">console</span>.log(ret);</span><br></pre></td></tr></table></figure>
<p><strong>什么是 arguments.callee？</strong></p>
<blockquote>
<p>返回正被执行的<code>function</code>对象，也就是所指定的<code>function</code>对象的正文。<code>callee</code>属性是<code>arguments</code> 对象的一个成员，它表示对函数对象本身的引用，这有利于匿名函数的递归或者保证函数的封装性。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>我们可以看到，打印的<code>arguments</code>属性里面有哪些参数：</p>
<p><img src="http://ww1.sinaimg.cn/large/007kscFEgy1fyl1o62ff1j30ad03p0sm.jpg" alt="arguments"></p>
<ul>
<li>前面几项是函数调用后传进来的实参；</li>
<li><code>callee:f</code>，它其实就是函数<code>fn</code>的引用，你可以理解为：<code>arguments.callee()</code>相当于<code>fn()</code>；</li>
<li><code>length</code>就是实参的长度。</li>
</ul>
<p><em>再去看上面斐波那契的案例，它的递归函数是一个匿名函数，所以在这个函数里面自己调用自己的时候，就是使用的<code>arguments.callee</code>去引用的。</em></p>
<h2 id="14-沙箱模式"><a class="header-anchor" href="#14-沙箱模式"></a>14. 沙箱模式</h2>
<blockquote>
<p>沙箱模式又称：沙盒模式、隔离模式。沙箱（<code>sandbox</code>）介绍：用于为一些来源不可信、具备破坏力或无法判定程序意图的程序提供试验环境。然而，沙盒中的所有改动对操作系统不会造成任何损失。</p>
</blockquote>
<h3 id="14-1-沙箱模式的作用"><a class="header-anchor" href="#14-1-沙箱模式的作用"></a>14.1 沙箱模式的作用</h3>
<ul>
<li>作用：对变量进行隔离</li>
<li>问题：在<code>js</code>中如何实现隔离？</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ES6之前， JavaScritp中只有函数能限定作用域，所以，只有使用函数才能实现隔离。</span><br></pre></td></tr></table></figure>
<p><em>本质上还是对函数作用域的应用。</em></p>
<h3 id="14-2-沙箱模式模型"><a class="header-anchor" href="#14-2-沙箱模式模型"></a>14.2 沙箱模式模型</h3>
<ul>
<li>使用自调用函数实现沙箱模式
<ul>
<li>函数形成独立的作用域；</li>
<li>函数只有被调用，内部代码才会执行；</li>
<li>将全局污染降到最低。</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 代码</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<h3 id="14-3-沙箱模式应用"><a class="header-anchor" href="#14-3-沙箱模式应用"></a>14.3 沙箱模式应用</h3>
<blockquote>
<p>最佳实践：在函数内定义变量的时候，将 变量定义 提到最前面。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 减少了window变量作用域的查找</span></span><br><span class="line"><span class="comment">// 2 有利于代码压缩</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"> window </span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"> selector </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.selector = selector;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  fn.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: fn,</span><br><span class="line">    addClass: function() &#123;&#125;,</span><br><span class="line">    removeClass: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 给window添加了一个 $属性，值为： fn</span></span><br><span class="line">  <span class="comment">// 暴露数据的方式:</span></span><br><span class="line">  <span class="built_in">window</span>.$ = fn;</span><br><span class="line"></span><br><span class="line">&#125;)( <span class="built_in">window</span> );</span><br></pre></td></tr></table></figure>
<h3 id="14-4-沙箱模式的说明"><a class="header-anchor" href="#14-4-沙箱模式的说明"></a>14.4 沙箱模式的说明</h3>
<ul>
<li>将代码放到一个立即执行的函数表达式(<code>IIFE</code>)中，这样就能实现代码的隔离；</li>
<li>使用<code>IIFE</code>：减少一个函数名称的污染，将全局变量污染降到最低；</li>
<li>代码在函数内部执行，函数内部声明的变量不会影响到函数外部；</li>
<li>如果外部需要，则可以返回数据或把要返回的数据交给<code>window</code>。</li>
</ul>
<p><em><code>IIFE: Immediately Invoke Function Expression</code>立即执行的函数表达式</em></p>
<h2 id="15-工厂模式"><a class="header-anchor" href="#15-工厂模式"></a>15. 工厂模式</h2>
<blockquote>
<p>工厂模式是一种设计模式，作用是：隐藏创建对象的细节，省略了使用<code>new</code>创建对象。</p>
</blockquote>
<p><strong>构造函数：</strong></p>
<blockquote>
<p>构造函数创建之后，我们实例化一个对象的时候都是直接通过<code>new</code>创建出来的。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'Levi'</span>, <span class="number">18</span>);</span><br></pre></td></tr></table></figure>
<p><strong>工厂函数：</strong></p>
<blockquote>
<p>工厂函数的核心就是隐藏这个<code>new</code>创建对象的细节。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Person(name, age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = createPerson(<span class="string">'Ryan'</span>, <span class="number">19</span>);</span><br></pre></td></tr></table></figure>
<p><em>两段代码比较下来，我们可以看到，实例出来的<code>p2</code>对象没有直接使用<code>new</code>创建，而是通过一个函数的返回值创建出来的，这就是工厂模式。</em></p>
<p><strong>使用场合：</strong></p>
<blockquote>
<p><code>jQuery</code>中，我们用的<code>“$”</code>或者<code>jQuery</code>函数，就是一个工厂函数。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Jquery 中的部分源码 */</span></span><br><span class="line"><span class="comment">// jQuery 实际上是一个 工厂函数，省略了 new 创建对象的操作</span></span><br><span class="line">jQuery = <span class="function"><span class="keyword">function</span>(<span class="params"> selector, context </span>) </span>&#123;</span><br><span class="line">    <span class="comment">// jQuery.fn.init 才是jQuery中真正的构造函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> jQuery.fn.init( selector, context );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（本篇完）</p>
</div><div class="toc-article" id="toc"><div class="toc-title"></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#js高级"><span class="toc-text">JS高级</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-异常处理"><span class="toc-text">1.异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1异常捕获"><span class="toc-text">1.1异常捕获</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2抛出异常"><span class="toc-text">1.2抛出异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3异常的传递机制"><span class="toc-text">1.3异常的传递机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-面向对象编程"><span class="toc-text">2.面向对象编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-面向过程和面向对象的的对比"><span class="toc-text">2.1 面向过程和面向对象的的对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-面向对象编程举例"><span class="toc-text">2.2 面向对象编程举例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-面向对象的三大特性"><span class="toc-text">2.3 面向对象的三大特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-创建对象的方式"><span class="toc-text">2.4 创建对象的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-面向对象案例"><span class="toc-text">2.5 面向对象案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-原型"><span class="toc-text">3.原型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-传统构造函数存在问题"><span class="toc-text">3.1 传统构造函数存在问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-原型的概念"><span class="toc-text">3.2 原型的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-原型的使用"><span class="toc-text">3.3 原型的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-proto-属性"><span class="toc-text">3.4 __proto__属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-constuctor属性"><span class="toc-text">3.5 constuctor属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-原型继承"><span class="toc-text">3.6 原型继承</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-原型链"><span class="toc-text">4.原型链</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-什么是原型链"><span class="toc-text">4.1 什么是原型链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-原型链的拓展"><span class="toc-text">4.2 原型链的拓展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-属性的搜索原则"><span class="toc-text">4.3 属性的搜索原则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-object-prototype成员介绍"><span class="toc-text">5.Object.prototype成员介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-constructor-属性"><span class="toc-text">5.1 constructor 属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-hasownproperty-方法"><span class="toc-text">5.2 hasOwnProperty 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-isprototypeof-方法"><span class="toc-text">5.3 isPrototypeOf 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-propertyisenumerable-方法"><span class="toc-text">5.4 propertyIsEnumerable 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-tostring-和-tolocalstring-方法"><span class="toc-text">5.5 toString 和 toLocalString 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-valueof-方法"><span class="toc-text">5.6 valueOf 方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-静态方法和实例方法"><span class="toc-text">6.静态方法和实例方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-作用域"><span class="toc-text">7.作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-块级作用域"><span class="toc-text">7.1 块级作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-词法作用域"><span class="toc-text">7.2 词法作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-变量提升-预解析"><span class="toc-text">7.3 变量提升（预解析）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-作用域链"><span class="toc-text">7.4 作用域链</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-function"><span class="toc-text">8.Function</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-创建函数的几种方式"><span class="toc-text">8.1 创建函数的几种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-function-构造函数创建函数"><span class="toc-text">8.2 Function 构造函数创建函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-function-的使用"><span class="toc-text">8.3 Function 的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-function-的原型链结构"><span class="toc-text">8.4 Function 的原型链结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-完整的原型链"><span class="toc-text">8.5 完整的原型链</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-arguments对象"><span class="toc-text">9.arguments对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-函数的四种调用模式"><span class="toc-text">10. 函数的四种调用模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-函数模式"><span class="toc-text">10.1 函数模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-方法模式"><span class="toc-text">10.2 方法模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-构造器模式"><span class="toc-text">10.3 构造器模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-上下文-借用方法-模式"><span class="toc-text">10.4 上下文（借用方法）模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-5-面试题分析"><span class="toc-text">10.5 面试题分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-递归"><span class="toc-text">11.递归</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-什么是递归"><span class="toc-text">11.1 什么是递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-化归思想"><span class="toc-text">11.2 化归思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3-递归练习"><span class="toc-text">11.3 递归练习</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-js-内存管理"><span class="toc-text">12. JS 内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1-内存生命周期"><span class="toc-text">12.1 内存生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-垃圾回收"><span class="toc-text">12.2 垃圾回收</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-闭包"><span class="toc-text">13. 闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-闭包的概念"><span class="toc-text">13.1 闭包的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2-闭包模型"><span class="toc-text">13.2 闭包模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3-闭包的使用"><span class="toc-text">13.3 闭包的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-4-闭包里的缓存"><span class="toc-text">13.4 闭包里的缓存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-沙箱模式"><span class="toc-text">14. 沙箱模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-1-沙箱模式的作用"><span class="toc-text">14.1 沙箱模式的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2-沙箱模式模型"><span class="toc-text">14.2 沙箱模式模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3-沙箱模式应用"><span class="toc-text">14.3 沙箱模式应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-沙箱模式的说明"><span class="toc-text">14.4 沙箱模式的说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-工厂模式"><span class="toc-text">15. 工厂模式</span></a></li></ol></li></ol></div><p class="ending">本篇完</p><div class="tags"><a class="tag-link" href="/tags/js高级/">js高级</a><a class="tag-link" href="/tags/原型/">原型</a><a class="tag-link" href="/tags/递归/">递归</a><a class="tag-link" href="/tags/闭包/">闭包</a><a class="tag-link" href="/tags/面向对象/">面向对象</a></div></section></div><div id="articleMenu"><i class="fa fa-list iconColor"></i></div><div class="container"><ul class="nav"><li>上一篇：<a href="/2019/01/02/原生js实现移动端Touch轮播图/">原生js实现移动端Touch轮播图</a></li><li>下一篇：<a href="/2018/12/06/一文让你理解什么是-JS-原型/">一文让你理解什么是 JS 原型</a></li></ul></div><div id="backToTop"><div class="back-arrow back-arrow-left"></div><div class="back-arrow back-arrow-right"></div></div><footer class="container"><div class="rights"><span>© 2018 </span><i class="fa fa-heartbeat iconColor"> </i><span>Levi丶</span></div></footer><canvas id="canvas"></canvas><script src="/script/jquery.min.js"></script><link rel="stylesheet" href="/fancybox/jquery.fancybox.css"><script src="/fancybox/jquery.fancybox.pack.js"></script><script src="/script/index.js"></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-61220413-1', 'auto');
ga('send', 'pageview');</script><script src="/script/post.js"></script></head></html>