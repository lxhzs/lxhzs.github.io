<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="description"><meta name="keyword"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>一文让你理解什么是 JS 原型</title><link rel="shortcut icon" href="/images/avatar.jpg" type="image/x-icon"><link href="/styles/site.css" rel="stylesheet"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><body></body><header class="container" id="header"><div class="header"><div class="header-left"><div class="avatar"><img src="/images/avatar.jpg"></div><div class="author"><div class="author-name"><a href="/">Ryan's Blog</a></div><div class="about-me">大家好，我叫李新华。我的域名是“李新华真帅”。</div></div></div><div class="header-right"><ul class="navigation"><li><a href="/"><i class="fa fa-fw fa-home"> </i><br>首页</a></li><li><a href="/"><i class="fa fa-fw fa-book"> </i><br>博客</a></li><li><a href="/archives"><i class="fa fa-fw fa-archive"> </i><br>归档</a></li><li><a href="/categories"><i class="fa fa-fw fa-th"> </i><br>分类</a></li><li><a href="/tags"><i class="fa fa-fw fa-tags"> </i><br>标签</a></li><li><a href="/life"><i class="fa fa-fw fa-heart"> </i><br>生活</a></li><li><a href="/about"><i class="fa fa-fw fa-user"> </i><br>关于</a></li></ul></div><div class="about-me-mask"><div class="about-me-wrap"><div class="about-me__header"><div class="avatar"><img src="/images/avatar.jpg"></div></div><ul class="socials"><li class="social-item"><span class="label"><img src="/images/socials/github.svg" alt="https://github.com/gary-Shen"></span><a href="https://github.com/gary-Shen" target="_blank" title="https://github.com/gary-Shen">https://github.com/gary-Shen</a></li><li class="social-item"><span class="label"><img src="/images/socials/email.svg" alt="guanlinshen@126.com"></span><span>guanlinshen@126.com</span></li><li class="social-item"><span class="label"><img src="/images/socials/wechat.svg" alt="Grinson"></span><span>Grinson</span></li></ul></div></div></div></header><div class="container post"><section class="article"><div class="title">一文让你理解什么是 JS 原型</div><div class="date">写于2018年12月06日</div><div class="content"><p><img src="http://ww1.sinaimg.cn/large/007kscFEgy1fxq2ayt269j31uo11iq52.jpg" alt="image"></p>
<a id="more"></a>
<h2 id="前言"><a class="header-anchor" href="#前言"></a>前言</h2>
<blockquote>
<p>最近整理了一部分的<code>JavaScript</code>知识点，由于<code>js</code>高级阶段涉及知识点比较复杂，文章一直没更新，这里单独将原型部分的概念拎出来理解下。</p>
</blockquote>
<h2 id="1-原型"><a class="header-anchor" href="#1-原型"></a>1.原型</h2>
<h3 id="1-1-传统构造函数存在问题"><a class="header-anchor" href="#1-1-传统构造函数存在问题"></a>1.1 传统构造函数存在问题</h3>
<p><strong>通过自定义构造函数的方式，创建小狗对象：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'汪汪汪'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> dog1 = <span class="keyword">new</span> Dog(<span class="string">'哈士奇'</span>, <span class="number">1.5</span>);</span><br><span class="line"><span class="keyword">var</span> dog2 = <span class="keyword">new</span> Dog(<span class="string">'大黄狗'</span>, <span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(dog1);</span><br><span class="line"><span class="built_in">console</span>.log(dog2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(dog1.say == dog2.say); <span class="comment">//输出结果为false</span></span><br></pre></td></tr></table></figure>
<p><strong>画个图理解下：</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/9c47d583gy1fs434nbijij20lg0ekt9b.jpg" alt="image"></p>
<p><em>每次创建一个对象的时候，都会开辟一个新的空间，我们从上图可以看出，每只创建的小狗有一个<code>say</code>方法，这个方法都是独立的，但是功能完全相同。随着创建小狗的数量增多，造成内存的浪费就更多，这就是我们需要解决的问题。</em></p>
<p><strong>为了避免内存的浪费，我们想要的其实是下图的效果：</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/9c47d583gy1fs5a5q7y6gj20nj0e53z3.jpg" alt="image"></p>
<p><strong>解决方法：</strong></p>
<blockquote>
<p>这里最好的办法就是将函数体放在构造函数之外，在构造函数中只需要引用该函数即可。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'汪汪汪'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.say = sayFn();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> dog1 = <span class="keyword">new</span> Dog(<span class="string">'哈士奇'</span>, <span class="number">1.5</span>);</span><br><span class="line"><span class="keyword">var</span> dog2 = <span class="keyword">new</span> Dog(<span class="string">'大黄狗'</span>, <span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(dog1);</span><br><span class="line"><span class="built_in">console</span>.log(dog2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(dog1.say == dog2.say); <span class="comment">//输出结果为true</span></span><br></pre></td></tr></table></figure>
<p><strong>这样写依然存在问题：</strong></p>
<ul>
<li>全局变量增多，会增加引入框架命名冲突的风险</li>
<li>代码结构混乱，会变得难以维护</li>
</ul>
<p><em>想要解决上面的问题就需要用到<code>构造函数的原型</code>概念。</em></p>
<h3 id="1-2-原型的概念"><a class="header-anchor" href="#1-2-原型的概念"></a>1.2 原型的概念</h3>
<blockquote>
<p><code>prototype</code>：原型。每个构造函数在创建出来的时候系统会自动给这个构造函数创建并且关联一个空的对象。这个空的对象，就叫做原型。</p>
</blockquote>
<p><strong>关键点：</strong></p>
<ul>
<li>每一个由构造函数创建出来的对象，都会默认的和构造函数的原型关联；</li>
<li>当使用一个方法进行属性或者方法访问的时候，会先在当前对象内查找该属性和方法，如果当前对象内未找到，就会去跟它关联的原型对象内进行查找；</li>
<li>也就是说，在原型中定义的方法跟属性，会被这个构造函数创建出来的对象所共享；</li>
<li>访问原型的方式：<code>构造函数名.prototype</code>。</li>
</ul>
<p><strong>示例图：</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/9c47d583gy1fs7akmd4jgj20h60bbweo.jpg" alt="image"></p>
<p><strong>示例代码：</strong> 给构造函数的原型添加方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给构造函数的原型 添加say方法</span></span><br><span class="line">Dog.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'汪汪汪'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dog1 = <span class="keyword">new</span> Dog(<span class="string">'哈士奇'</span>, <span class="number">1.5</span>);</span><br><span class="line"><span class="keyword">var</span> dog2 = <span class="keyword">new</span> Dog(<span class="string">'大黄狗'</span>, <span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">dog1.say();  <span class="comment">// 汪汪汪</span></span><br><span class="line">dog2.say();  <span class="comment">// 汪汪汪</span></span><br></pre></td></tr></table></figure>
<p><em>我们可以看到，本身<code>Dog</code>这个构造函数中是没有<code>say</code>这个方法的，我们通过<code>Dog.prototype.say</code>的方式，在构造函数<code>Dog</code>的原型中创建了一个方法，实例化出来的<code>dog1</code>、<code>dog2</code>会先在自己的对象先找<code>say</code>方法，找不到的时候，会去他们的原型对象中查找。</em></p>
<p><strong>如图所示：</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/9c47d583gy1fs86or8wkij20m40gtwf5.jpg" alt="创建一个原型对象"></p>
<p><em>在构造函数的原型中可以存放所有对象共享的数据，这样可以避免多次创建对象浪费内存空间的问题。</em></p>
<h3 id="1-3-原型的使用"><a class="header-anchor" href="#1-3-原型的使用"></a>1.3 原型的使用</h3>
<p><strong>1、使用对象的动态特性</strong></p>
<blockquote>
<p>使用对象的动态属性，其实就是直接使用<code>prototype</code>为原型添加属性或者方法。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">'讲了一句话'</span> );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person.prototype.age = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br><span class="line">p.say();  <span class="comment">// 讲了一句话</span></span><br><span class="line"><span class="built_in">console</span>.log(p.age);  <span class="comment">// 18</span></span><br></pre></td></tr></table></figure>
<p><strong>2、直接替换原型对象</strong></p>
<blockquote>
<p>每次构造函数创建出来的时候，都会关联一个空对象，我们可以用一个对象替换掉这个空对象。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    say : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">'讲了一句话'</span> );</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br><span class="line">p.say();  <span class="comment">// 讲了一句话</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<blockquote>
<p>使用原型的时候，有几个注意点需要注意一下，我们通过几个案例来了解一下。</p>
</blockquote>
<ul>
<li>使用<code>对象.属性名</code>去获取对象属性的时候，会先在自身中进行查找，如果没有，就去原型中查找；</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个英雄的构造函数 它有自己的 name 和 age 属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hero</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=<span class="string">"德玛西亚之力"</span>;</span><br><span class="line">    <span class="keyword">this</span>.age=<span class="number">18</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给这个构造函数的原型对象添加方法和属性</span></span><br><span class="line">Hero.prototype.age= <span class="number">30</span>;</span><br><span class="line">Hero.prototype.say=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'人在塔在！！！'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> h1 = <span class="keyword">new</span> Hero();</span><br><span class="line">h1.say();   <span class="comment">// 先去自身中找 say 方法，没有再去原型中查找  打印：'人在塔在！！！'</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.name);  <span class="comment">// "德玛西亚之力"</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.age);   <span class="comment">// 18 先去自身中找 age 属性，有的话就不去原型中找了</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用<code>对象.属性名</code>去设置对象属性的时候，只会在自身进行查找，如果有，就修改，如果没有，就添加；</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个英雄的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hero</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=<span class="string">"德玛西亚之力"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给这个构造函数的原型对象添加方法和属性</span></span><br><span class="line">Hero.prototype.age = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> h1 = <span class="keyword">new</span> Hero();</span><br><span class="line"><span class="built_in">console</span>.log(h1);       <span class="comment">// &#123;name:"德玛西亚之力"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(h1.age);   <span class="comment">// 18</span></span><br><span class="line"></span><br><span class="line">h1.age = <span class="number">30</span>;           <span class="comment">// 设置的时候只会在自身中操作，如果有，就修改，如果没有，就添加 不会去原型中操作</span></span><br><span class="line"><span class="built_in">console</span>.log(h1);       <span class="comment">// &#123;name:"德玛西亚之力",age:30&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(h1.age);   <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>一般情况下，不会将属性放在原型中，只会将方法放在原型中；</p>
</li>
<li>
<p>在替换原型的时候，替换之前创建的对象，和替换之后创建的对象的原型不一致！！！</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个英雄的构造函数 它有自己的 name 属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hero</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=<span class="string">"德玛西亚之力"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给这个构造函数的默认原型对象添加 say 方法</span></span><br><span class="line">Hero.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'人在塔在！！！'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> h1 = <span class="keyword">new</span> Hero();</span><br><span class="line"><span class="built_in">console</span>.log(h1);    <span class="comment">// &#123;name:"德玛西亚之力"&#125;</span></span><br><span class="line">h1.say();           <span class="comment">// '人在塔在！！！'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 开辟一个命名空间 obj，里面有个 kill 方法</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    kill : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'大宝剑'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将创建的 obj 对象替换原本的原型对象</span></span><br><span class="line">Hero.prototype = obj;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> h2 = <span class="keyword">new</span> Hero();</span><br><span class="line"></span><br><span class="line">h1.say();           <span class="comment">// '人在塔在！！！'</span></span><br><span class="line">h2.say();           <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line">h1.kill();          <span class="comment">// 报错</span></span><br><span class="line">h2.kill();          <span class="comment">// '大宝剑'</span></span><br></pre></td></tr></table></figure>
<p>画个图理解下：</p>
<p><img src="http://ww1.sinaimg.cn/large/9c47d583gy1fs8hq4jgt1j20rv0hjjs5.jpg" alt="image"></p>
<p><em>图中可以看出，实例出来的<code>h1</code>对象指向的原型中，只有<code>say()</code>方法，并没有<code>kill()</code>方法，所以<code>h1.kill()</code>会报错。同理，<code>h2.say()</code>也会报错。</em></p>
<h3 id="1-4-proto-属性"><a class="header-anchor" href="#1-4-proto-属性"></a>1.4 __proto__属性</h3>
<blockquote>
<p>在<code>js</code>中以<code>_</code>开头的属性名为<code>js</code>的私有属性，以<code>__</code>开头的属性名为非标准属性。<code>__proto__</code>是一个非标准属性，最早由<code>firefox</code>提出来。</p>
</blockquote>
<p><strong>1、构造函数的 prototype 属性</strong></p>
<blockquote>
<p>之前我们访问构造函数原型对象的时候，使用的是<code>prototype</code>属性：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过构造函数的原型属性prototype可以直接访问原型</span></span><br><span class="line">Person.prototype;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在之前我们是无法通过构造函数<code>new</code>出来的对象访问原型的：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="comment">//以前不能直接通过p来访问原型对象</span></span><br></pre></td></tr></table></figure>
<p><strong>2、实例对象的 __proto__ 属性</strong></p>
<blockquote>
<p><code>__proto__</code>属性最早是火狐浏览器引入的，用以通过实例对象来访问原型，这个属性在早期是非标准的属性，有了<code>__proto__</code>属性，就可以通过构造函数创建出来的对象直接访问原型。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例对象的__proto__属性可以方便的访问到原型对象</span></span><br><span class="line">p.__proto__;</span><br><span class="line"></span><br><span class="line"><span class="comment">//既然使用构造函数的`prototype`和实例对象的`__proto__`属性都可以访问原型对象</span></span><br><span class="line"><span class="comment">//就有如下结论</span></span><br><span class="line">p.__proto__ === Person.prototype;</span><br></pre></td></tr></table></figure>
<p><strong>如图所示：</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/9c47d583gy1fs8l1aq567j20i60d53ym.jpg" alt="image"></p>
<p><strong>3、__proto__属性的用途</strong></p>
<ul>
<li>可以用来访问原型；</li>
<li>在实际开发中除非有特殊的需求，不要轻易的使用实例对象的<code>__proto__</code>属性去修改原型的属性或方法；</li>
<li>在调试过程中，可以轻易的查看原型的成员；</li>
<li>由于兼容性问题，不推荐使用。</li>
</ul>
<h3 id="3-5-constuctor属性"><a class="header-anchor" href="#3-5-constuctor属性"></a>3.5 constuctor属性</h3>
<blockquote>
<p><code>constructor</code>：构造函数，原型的<code>constructor</code>属性指向的是和原型关联的构造函数。</p>
</blockquote>
<p><strong>示例代码：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=<span class="string">"husky"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d=<span class="keyword">new</span> Dog();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取构造函数</span></span><br><span class="line"><span class="built_in">console</span>.log(Dog.prototype.constructor);  <span class="comment">// 打印构造函数 Dog</span></span><br><span class="line"><span class="built_in">console</span>.log(d.__proto__.constructor);    <span class="comment">// 打印构造函数 Dog</span></span><br></pre></td></tr></table></figure>
<p><strong>如图所示：</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/9c47d583gy1fs8m891kohj20ky0bejrq.jpg" alt="image"></p>
<p><strong>获取复杂类型的数据类型：</strong></p>
<blockquote>
<p>通过<code>obj.constructor.name</code>的方式，获取当前对象<code>obj</code>的数据类型。</p>
</blockquote>
<p><em>在一个的函数中，有个返回值<code>name</code>，它表示的是当前函数的函数名；</em></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Teacher</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> teacher = <span class="keyword">new</span> Teacher();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假使我们只知道一个对象teacher，如何获取它的类型呢？</span></span><br><span class="line"><span class="built_in">console</span>.log(teacher.__proto__.constructor.name);  <span class="comment">// Teacher</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(teacher.constructor.name);  <span class="comment">// Teacher</span></span><br></pre></td></tr></table></figure>
<p><em>实例化出来的<code>teacher</code>对象，它的数据类型是啥呢？我们可以通过实例对象<code>teacher.__proto__</code>，访问到它的原型对象，再通过<code>.constructor</code>访问它的构造函数，通过<code>.name</code>获取当前函数的函数名，所以就能得到当前对象的数据类型。又因为<code>.__proto__</code>是一个非标准的属性，而且实例出的对象继承原型对象的方法，所以直接可以写成：<code>obj.constructor.name</code>。</em></p>
<h3 id="1-6-原型继承"><a class="header-anchor" href="#1-6-原型继承"></a>1.6 原型继承</h3>
<blockquote>
<p><code>原型继承</code>：每一个构造函数都有<code>prototype</code>原型属性，通过构造函数创建出来的对象都继承自该原型属性。所以可以通过更改构造函数的原型属性来实现继承。</p>
</blockquote>
<p><em>继承的方式有多种，可以一个对象继承另一个对象，也可以通过原型继承的方式进行继承。</em></p>
<p><strong>1、简单混入继承</strong></p>
<blockquote>
<p>直接遍历一个对象，将所有的属性和方法加到另一对象上。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> animal = &#123;</span><br><span class="line">    name:<span class="string">"Animal"</span>,</span><br><span class="line">    sex:<span class="string">"male"</span>,</span><br><span class="line">    age:<span class="number">5</span>,</span><br><span class="line">    bark:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Animal bark"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dog = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> animal)&#123;</span><br><span class="line">    dog[k]= animal[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(dog);  <span class="comment">// 打印的对象与animal一模一样</span></span><br></pre></td></tr></table></figure>
<p><em>缺点：只能一个对象继承自另一个对象，代码复用太低了。</em></p>
<p><strong>2、混入式原型继承</strong></p>
<blockquote>
<p>混入式原型继承其实与上面的方法类似，只不过是将遍历的对象添加到构造函数的原型上。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">     name:<span class="string">'zs'</span>,</span><br><span class="line">     age:<span class="number">19</span>,</span><br><span class="line">     sex:<span class="string">'male'</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.weight=<span class="number">50</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> obj)&#123;</span><br><span class="line">    <span class="comment">// 将obj里面的所有属性添加到 构造函数 Person 的原型中</span></span><br><span class="line">    Person.prototype[k] = obj[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1=<span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> p2=<span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> p3=<span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1.name);  <span class="comment">// 'zs'</span></span><br><span class="line"><span class="built_in">console</span>.log(p2.age);   <span class="comment">// 19</span></span><br><span class="line"><span class="built_in">console</span>.log(p3.sex);   <span class="comment">// 'male'</span></span><br></pre></td></tr></table></figure>
<p><strong>面向对象思想封装一个原型继承</strong></p>
<blockquote>
<p>我们可以利用面向对象的思想，将面向过程进行封装。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = <span class="string">'yellow Dog'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给构造函数 Dog 添加一个方法 extend</span></span><br><span class="line">Dog.prototype.extend = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 使用混入式原型继承，给 Dog 构造函数的原型继承 obj 的属性和方法</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> obj)&#123;</span><br><span class="line">        <span class="keyword">this</span>[k]=obj[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 extend 方法</span></span><br><span class="line">Dog.prototype.extend(&#123;</span><br><span class="line">    name:<span class="string">"二哈"</span>,</span><br><span class="line">    age:<span class="string">"1.5"</span>,</span><br><span class="line">    sex:<span class="string">"公"</span>,</span><br><span class="line">    bark:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'汪汪汪'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>3、替换式原型继承</strong></p>
<blockquote>
<p>替换式原型继承，在上面已经举过例子了，其实就是将一个构造函数的原型对象替换成另一个对象。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.weight=<span class="number">50</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">    name:<span class="string">'zs'</span>,</span><br><span class="line">    age:<span class="number">19</span>,</span><br><span class="line">    sex:<span class="string">'male'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将一个构造函数的原型对象替换成另一个对象</span></span><br><span class="line">Person.prototype = obj;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1=<span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> p2=<span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> p3=<span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1.name);  <span class="comment">// 'zs'</span></span><br><span class="line"><span class="built_in">console</span>.log(p2.age);   <span class="comment">// 19</span></span><br><span class="line"><span class="built_in">console</span>.log(p3.sex);   <span class="comment">// 'male'</span></span><br></pre></td></tr></table></figure>
<p><em>之前我们就说过，这样做会产生一个问题，就是替换的对象会重新开辟一个新的空间。</em></p>
<p><strong>替换式原型继承时的bug</strong></p>
<blockquote>
<p>替换原型对象的方式会导致原型的<code>constructor</code>的丢失，<code>constructor</code>属性是默认原型对象指向构造函数的，就算是替换了默认原型对象，这个属性依旧是默认原型对象指向构造函数的，所以新的原型对象是没有这个属性的。</p>
</blockquote>
<p><img src="http://ww1.sinaimg.cn/large/9c47d583gy1fs8o69va2rj20rd0gut9r.jpg" alt="image"></p>
<p>解决方法：手动关联一个<code>constructor</code>属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.weight = <span class="number">50</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'zs'</span>,</span><br><span class="line">    age: <span class="number">19</span>,</span><br><span class="line">    sex: <span class="string">'male'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在替换原型对象函数之前 给需要替换的对象添加一个 constructor 属性 指向原本的构造函数</span></span><br><span class="line">obj.constructor = Person;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个构造函数的原型对象替换成另一个对象</span></span><br><span class="line">Person.prototype = obj;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1.__proto__.constructor === Person);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><strong>4、Object.create()方法实现原型继承</strong></p>
<blockquote>
<p>当我们想把<code>对象1</code>作为<code>对象2</code>的原型的时候，就可以实现<code>对象2</code>继承<code>对象1</code>。前面我们了解了一个属性：<code>__proto__</code>，实例出来的对象可以通过这个属性访问到它的原型，但是这个属性只适合开发调试时使用，并不能直接去替换原型对象。所以这里介绍一个新的方法：<code>Object.create()</code>。</p>
</blockquote>
<p><strong>语法：</strong> <code>var obj1 = Object.create(原型对象);</code></p>
<p><strong>示例代码：</strong> 让空对象<code>obj1</code>继承对象<code>obj</code>的属性和方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name : <span class="string">'盖伦'</span>,</span><br><span class="line">    age : <span class="number">25</span>,</span><br><span class="line">    skill : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'大宝剑'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个方法会帮我们创建一个原型是 obj 的对象</span></span><br><span class="line"><span class="keyword">var</span> obj1 = <span class="built_in">Object</span>.create(obj);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj1.name);     <span class="comment">// "盖伦"</span></span><br><span class="line">obj1.skill();               <span class="comment">// "大宝剑"</span></span><br></pre></td></tr></table></figure>
<p><strong>兼容性：</strong></p>
<blockquote>
<p>由于这个属性是<code>ECMAScript5</code>的时候提出来的，所以存在兼容性问题。</p>
</blockquote>
<p>利用浏览器的<code>能力检测</code>，如果存在<code>Object.create</code>则使用，如果不存在的话，就创建构造函数来实现原型继承。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装一个能力检测函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 判断，如果浏览器有 Object.create 方法的时候</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Object</span>.create)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.create(obj);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 创建构造函数 Fun</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">Fun</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">        Fun.prototype = obj; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Fun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hero = &#123;</span><br><span class="line">    name: <span class="string">'盖伦'</span>,</span><br><span class="line">    age: <span class="number">25</span>,</span><br><span class="line">    skill: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'大宝剑'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hero1 = create(hero);</span><br><span class="line"><span class="built_in">console</span>.log(hero1.name);    <span class="comment">// "盖伦"</span></span><br><span class="line"><span class="built_in">console</span>.log(hero1.__proto__ == hero);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="2-原型链"><a class="header-anchor" href="#2-原型链"></a>2.原型链</h2>
<blockquote>
<p>对象有原型，原型本身又是一个对象，所以原型也有原型，这样就会形成一个链式结构的原型链。</p>
</blockquote>
<h3 id="2-1-什么是原型链"><a class="header-anchor" href="#2-1-什么是原型链"></a>2.1 什么是原型链</h3>
<p><strong>示例代码：</strong> 原型继承练习</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 Animal 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.weight = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">this</span>.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'蜂蜜蜂蜜'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化一个 animal 对象</span></span><br><span class="line"><span class="keyword">var</span> animal = <span class="keyword">new</span> Animal();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 Preson 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'zs'</span>;</span><br><span class="line">    <span class="keyword">this</span>.tool = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'菜刀'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让 Person 继承 animal （替换原型对象）</span></span><br><span class="line">Person.prototype = animal;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化一个 p 对象 </span></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 Student 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.score = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">this</span>.clickCode = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'啪啪啪'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让 Student 继承 p （替换原型对象）</span></span><br><span class="line">Student.prototype = p;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化一个 student 对象</span></span><br><span class="line"><span class="keyword">var</span> student = <span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(student);           <span class="comment">// 打印 &#123;score:100,clickCode:fn&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为是一级级继承下来的 所以最上层的 Animate 里的属性也是被继承的</span></span><br><span class="line"><span class="built_in">console</span>.log(student.weight);    <span class="comment">// 50</span></span><br><span class="line">student.eat();         <span class="comment">// 蜂蜜蜂蜜</span></span><br><span class="line">student.tool();        <span class="comment">// 菜刀</span></span><br></pre></td></tr></table></figure>
<p><strong>如图所示：</strong></p>
<blockquote>
<p>我们将上面的案例通过画图的方式展现出来后就一目了然了，实例对象<code>animal</code>直接替换了构造函数<code>Person</code>的原型，以此类推，这样就会形成一个链式结构的原型链。</p>
</blockquote>
<p><img src="http://ww1.sinaimg.cn/large/9c47d583gy1fs9k7z43o6j20ob0kojs3.jpg" alt="image"></p>
<p><strong>完整的原型链</strong></p>
<blockquote>
<p>结合上图，我们发现，最初的构造函数<code>Animal</code>创建的同时，会创建出一个原型，此时的原型是一个空的对象。结合原型链的概念：“原型本身又是一个对象，所以原型也有原型”，那么这个空对象往上还能找出它的原型或者构造函数吗？</p>
</blockquote>
<p><em>我们如何创建一个空对象？ 1、字面量：<code>{}</code>；2、构造函数：<code>new Object()</code>。我们可以简单的理解为，这个空的对象就是，构造函数<code>Object</code>的实例对象。所以，这个空对象往上面找是能找到它的原型和构造函数的。</em></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 Animal 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.weight = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">this</span>.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'蜂蜜蜂蜜'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化一个 animal 对象</span></span><br><span class="line"><span class="keyword">var</span> animal = <span class="keyword">new</span> Animal();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(animal.__proto__);      <span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(animal.__proto__.__proto__);  <span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(animal.__proto__.__proto__.constructor);  <span class="comment">// function Object()&#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(animal.__proto__.__proto__.__proto__);  <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<p><strong>如图所示：</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/9c47d583gy1fs9lq5dpasj20uk0jn3zu.jpg" alt="image"></p>
<h3 id="2-2-原型链的拓展"><a class="header-anchor" href="#2-2-原型链的拓展"></a>2.2 原型链的拓展</h3>
<p><strong>1、描述出数组[]的原型链结构</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个数组</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们可以看到这个数组是构造函数 Array 的实例对象，所以他的原型应该是：</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype);   <span class="comment">// 打印出来还是一个空数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们可以继续往上找 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.__proto__);  <span class="comment">// 空对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.__proto__.__proto__)  <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<p><strong>如图所示：</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/9c47d583gy1fs9n5cdbapj20nr0k1jsc.jpg" alt="image"></p>
<p><strong>2、扩展内置对象</strong></p>
<blockquote>
<p>给<code>js</code>原有的内置对象，添加新的功能。</p>
</blockquote>
<p><em>注意：这里不能直接给内置对象的原型添加方法，因为在开发的时候，大家都会使用到这些内置对象，假如大家都是给内置对象的原型添加方法，就会出现问题。</em></p>
<p>错误的做法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个开发人员给 Array 原型添加了一个 say 方法</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'哈哈哈'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个开发人员也给 Array 原型添加了一个 say 方法</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'啪啪啪'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line">arr.say();  <span class="comment">// 打印 “啪啪啪”  前面写的会被覆盖</span></span><br></pre></td></tr></table></figure>
<p>为了避免出现这样的问题，只需自己定义一个构造函数，并且让这个构造函数继承数组的方法即可，再去添加新的方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个数组对象 这个数组对象继承了所有数组中的方法</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个属于自己的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyArray</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只需要将自己创建的构造函数的原型替换成 数组对象，就能继承数组的所有方法</span></span><br><span class="line">MyArray.prototype = arr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在可以单独的给自己创建的构造函数的原型添加自己的方法</span></span><br><span class="line">MyArray.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'这是我自己添加的say方法'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr1 = <span class="keyword">new</span> MyArray();</span><br><span class="line"></span><br><span class="line">arr1.push(<span class="number">1</span>);   <span class="comment">// 创建的 arr1 对象可以使用数组的方法</span></span><br><span class="line">arr1.say();     <span class="comment">// 也可以使用自己添加的方法  打印“这是我自己添加的say方法”</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1);  <span class="comment">// [1]</span></span><br></pre></td></tr></table></figure>
<h3 id="2-3-属性的搜索原则"><a class="header-anchor" href="#2-3-属性的搜索原则"></a>2.3 属性的搜索原则</h3>
<blockquote>
<p>当通过<code>对象名.属性名</code>获取属性是 ，会遵循以下属性搜索的原则：</p>
</blockquote>
<ul>
<li>1-首先去对象自身属性中找，如果找到直接使用，</li>
<li>2-如果没找到去自己的原型中找，如果找到直接使用，</li>
<li>3-如果没找到，去原型的原型中继续找，找到直接使用，</li>
<li>4-如果没有会沿着原型不断向上查找，直到找到<code>null</code>为止。</li>
</ul>
</div><div class="toc-article" id="toc"><div class="toc-title"></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-原型"><span class="toc-text">1.原型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-传统构造函数存在问题"><span class="toc-text">1.1 传统构造函数存在问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-原型的概念"><span class="toc-text">1.2 原型的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-原型的使用"><span class="toc-text">1.3 原型的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-proto-属性"><span class="toc-text">1.4 __proto__属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-constuctor属性"><span class="toc-text">3.5 constuctor属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-原型继承"><span class="toc-text">1.6 原型继承</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-原型链"><span class="toc-text">2.原型链</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-什么是原型链"><span class="toc-text">2.1 什么是原型链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-原型链的拓展"><span class="toc-text">2.2 原型链的拓展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-属性的搜索原则"><span class="toc-text">2.3 属性的搜索原则</span></a></li></ol></li></ol></div><p class="ending">本篇完</p><div class="tags"><a class="tag-link" href="/tags/原型/">原型</a><a class="tag-link" href="/tags/原型继承/">原型继承</a><a class="tag-link" href="/tags/原型链/">原型链</a></div></section></div><div id="articleMenu"><i class="fa fa-list iconColor"></i></div><div class="container"><ul class="nav"><li>上一篇：<a href="/2018/12/27/JS-进阶知识-高级篇/">JS 进阶知识-高级篇</a></li><li>下一篇：<a href="/2018/11/22/CSS3-入门详解/">CSS3 入门详解</a></li></ul></div><div id="backToTop"><div class="back-arrow back-arrow-left"></div><div class="back-arrow back-arrow-right"></div></div><footer class="container"><div class="rights"><span>© 2018 </span><i class="fa fa-heartbeat iconColor"> </i><span>Ryan </span></div></footer><canvas id="canvas"></canvas><script src="/script/jquery.min.js"></script><link rel="stylesheet" href="/fancybox/jquery.fancybox.css"><script src="/fancybox/jquery.fancybox.pack.js"></script><script src="/script/index.js"></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-61220413-1', 'auto');
ga('send', 'pageview');</script><script src="/script/post.js"></script></head></html>